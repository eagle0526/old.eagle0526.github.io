---
title: Django學習
author: YeeChen
date: 2022-12-22
category: WEB
layout: post
---


> ---    
> **前情提要：**         
> 安裝 Django 環境
>    
> ---    
{: .block-tip}



Django 安裝環境
------

參考連結： https://carolhsu.gitbooks.io/django-girls-tutorial-traditional-chiness/content/django_installation/README.html


### 先在目錄生成一個虛擬環境資料夾

#### 確認在哪裡
```shell
$ pwd          
/Users/yee0526
```

#### 生成資料夾
```shell
$ mkdir djangogirls     
$ ls            

------
djangogirls         myblog ...... 其他資料夾
```


#### 進到該資料夾，新增虛擬環境資料夾
```shell
$ cd djangogirls
$ python3 -m venv myvenv
```


#### 進入虛擬環境

* bash
```bash
$ (base) yeedeAir:mytestsite yee0526$ source virtualenv/bin/activate

------
(virtualenv) (base) yeedeAir:djangogirls yee0526$           # 啟動後，我們會發現最前面多了虛擬環境的標籤，這樣代表我們進到了虛擬環境
```

* zsh
```zsh
# 還沒啟動前，時間右邊是空的，我們來輸入啟動虛擬環境的指令
$ Yee Mac-Air ~/djangogirls
> source virtualenv/bin/activate                                                                                ✔  10:38:27

# 可以發現時間右邊出現了 virtualenv 代表目前在虛擬環境裡面
$ Yee Mac-Air  ~/djangogirls 
> cd mytestsite                                                                                    ✔  10:38:32  virtualenv
```

Ps. 如果今天用 zsh 輸入了 `source virtualenv/bin/activate` 沒有任何錯誤，但是沒有進入虛擬環境的標籤，有很大的機率是你的 zsh 設定沒有把該標籤加入，只要加進去就可以

```md
<!-- 我的 zshrc 設定檔是這樣 -->
> POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir dir_writable vcs newline)
> POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status time virtualenv)
```
#### Django 設定資料庫

```bash
$ (virtualenv) (base) yeedeAir:python manage.py migrate
```

#### 啟動 server

* bash

先進到裡面那一層資料夾，在執行這指令 `python manage.py runserver`，可以看到終端機跟你說可以打開的網址，打開它就可以看到我們成功執行環境了！

```bash
$ (virtualenv) (base) yeedeAir:djangogirls yee0526$ cd mytestsite/
$ (virtualenv) (base) yeedeAir:mytestsite yee0526$ python3 manage.py runserver

------
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).
June 12, 2023 - 15:24:43
Django version 4.2.2, using settings 'mytestsite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

#### 離開虛擬環境 - deactivate

輸入 `deactivate` 後，可以發現前面的 `virtualenv` 就消失了！
```bash
$ (virtualenv) (base) yeedeAir:mytestsite yee0526$ deactivate


-----
$ (base) yeedeAir:mytestsite yee0526$ 
```



Django 建立新應用程式
------

### 新增專案

打上下面的指令，就會產生一個資料夾
```shell
$ django-admin startproject mysite
```


### 資料夾介紹

```md
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
```

這些目錄和文件的用途是：

* 最外層的mysite/根目錄只是你項目的容器，根目錄名稱對 Django 沒有影響，你可以將它重命名為任何你喜歡的名稱。
* manage.py: 一個讓你用各種方式管理 Django 項目的命令工具。你可以閱讀django-admin 和 manage.py獲取所有manage.py的細節。
* 裡面一層的mysite/ 目錄包含你的項目，它是一個純Python包。它的名字就是當你引用它內部任何東西時需要用到的Python包名mysite.urls。
* mysite/__init__.py：一個空文件，告訴 Python 這個目錄應該被認為是一個 Python 包。如果你是 Python 初學者，閱讀官方文檔中更多關於包的知識。
* mysite/settings.py：Django項目的配置文件。如果你想知道這個文件是如何工作的，請查看Django配置了解細節。
* mysite/urls.py：Django 項目的 URL 聲明，就像你網站的“目錄”。閱讀URL 調度器文檔來獲取更多關於 URL 的內容。
* mysite/asgi.py：為你的項目的運行在 ASGI 包含的 Web 服務器上的入口。閱讀如何使用 ASGI 來部分了解更多細節。
* mysite/wsgi.py：為你的項目的運行在 WSGI 包含的 Web 服務上的入口。閱讀如何使用 WSGI 進入部分了解了更多細節。




### 啟動 server
```shell
$ python manage.py runserver
```
Ps. 如果今天有開虛擬環境，記得要先進到內層，再開啟 server



## 投票應用 - 第一部分

現在你的發展環境——這個“項目”——已經配置好了，你就可以開始乾活了。
在Django中，每一個應用都是一個Python包，並且遵循相同的約定。Django自帶一個工具，可以幫助你生成應用的基礎目錄結構，這樣你就可以專心寫代碼，而不是創建目錄了。


> ---    
> **項目和應用有什麼區別？**     
> 應用是一個專門做某事的網絡應用程序——比如博客系統，或者使用者公共記錄的數據庫，或者小型的投票程序。     
> 項目則是一個網站使用的配置和應用的集合。項目可以包含很多應用。應用可以被很多項目使用。     
>    
> ---    
{: .block-tip}



請確定你現在位於manage.py所處的目錄下，然後運行此行命令來創建一個應用程序：
```shell
$ python manage.py startapp polls
```

這個指令會組造一個資料夾：
```md
> polls/
>     __init__.py
>     admin.py
>     apps.py
>     migrations/
>         __init__.py
>     models.py
>     tests.py
>     views.py
```


讓我來書寫第一個 view 吧

```py
# polls/views.py

from django.http import HttpResponse


def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
```


這是Django中最簡單的視圖。如果想看效果，我們需要將一個URL映射到它——這就是我們需要URLconf的原因了。   
要在 polls 目錄中創建 URLconf，請創建一個名為urls.py. 您的應用程序目錄現在應該如下所示：     

```md
> polls/
>     __init__.py
>     admin.py
>     apps.py
>     migrations/
>         __init__.py
>     models.py
>     tests.py
>     urls.py                 -> 這個
>     views.py
```


並在這個檔案輸入以下code
```py
# polls/urls.py

from django.urls import path

from . import views

urlpatterns = [
    path("", views.index, name="index"),
]
```



下一步是要在根URLconf文件中指定我們創建的polls.urls模板。在mysite/urls.py文件的urlpatterns列表裡插入一個include()，如下：


```py
# mysite/urls.py

from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("polls/", include("polls.urls")),
    path("admin/", admin.site.urls),
]
```

參數include()允許引用其URLconfs。每次當Django遇到include()時，它會截斷與此項匹配的URL的部分，並將剩下的字符發送到URLconf以提供一步驟處理。   
     
我們設計include()的理論是使其可以立即插入。由於投票應用有它自己的 URLconf( polls/urls.py)，他們能夠足夠被釋放在 "/polls/" ， "/fun_polls/" ，"/content/polls/"，或者其他任何路向下，這個應用都能夠正常工作。     


> ---        
> **何時使用include()?**     
> 當包包括它的 URL 模式時你應該總是使用include()，admin.site.urls是唯一一個例子。    
>    
> ---    
{: .block-tip}


### 啟動 server

這邊我們再啟動 server 一次，並連到網址 `http://127.0.0.1:8000/polls/` ，就可以看到我們剛剛在  `views` 中輸入的那一段文字！



### path() 的四個參數

函數工具path()有四個參數，兩個必須參數：route和view，兩個可選參數：kwargs和name。現在，是時候來研究這些參數的含義了。
```py
path("polls/", include("polls.urls")),
path("admin/", admin.site.urls),
```
1. route
route是一個匹配URL的準則（類似正規表達式）。當Django響應一個請求時，它會從第一項urlpatterns開始，按順次依次匹配表中的項目，直接找到匹配的項目。  
這些準則不會匹配 GET 和 POST 參數或域名稱。例如，URLconf 在處理請求時https://www.example.com/myapp/，它會嘗試匹配myapp/。處理請求https://www.example.com/myapp/?page=3時，也只會嘗試匹配myapp/。     

2. view
當Django找到了一個匹配的準則，就會調用這個特定的視頻函數，並傳入一個對像作為HttpRequest第一個參與數，被“捕獲”的參與數以將關鍵字參數的格式輸入。訂完後，我們會給出一個例子。  

3. kwarg
任意一個關鍵字參數可以作為一個字典傳遞給目標圖像函數。本教程中不會使用這種特性。

4. name
為你的 URL 取名能使你在 Django 的任意地方唯一引用它，尤其在模板中。這個有用的特性允許你只修改一個文件就可以全面修改某個 URL 模式。   
當你了解了基礎的請求和響應流程後，請閱讀教程的第 2 部分 開始使用數據庫。     





## 投票應用 - 第二部分


### 數據庫配置

現在，打開mysite/settings.py。這是一個包含了 Django 項目設置的 Python 模塊。

通常，這個配置文件使用SQLite作為默認數據庫。如果你不熟悉數據庫，或者只是想試下Django，這是最簡單的選擇。Python設置SQLite，所以你不需要安裝外部東西來使用它。當你開始一個真正的正確在項目的時候，你可能更傾向於使用一個更全面的數據庫，例如 PostgreSQL，避免中途切換數據庫這個讓人頭疼的問題。

如果你想使用其他數據庫，你需要安裝合適的數據庫綁定，然後修改設置文件中 項目目錄中的一些關鍵字：DATABASES 'default'

* ENGINE-- 可選值
    -- 有'django.db.backends.sqlite3'，'django.db.backends.postgresql'，'django.db.backends.mysql'，或'django.db.backends.oracle'。其可用後端。  
* NAME-- 數據庫的名稱。如果你使用SQLite，數據庫將是你電腦上的一個文件，在這種情況下，NAME應該是這個文件完整的絕對路徑，包含文件名。默認值將把數據庫文件存儲在項目目錄的根據目錄。BASE_DIR / 'db.sqlite3'     
     
如果你不使用SQLite，則必須添加一些外部設置，例如USER、PASSWORD、 HOST 等。想了解更多數據庫設置方面的內容，請看文檔：DATABASES。

> ---    
> **SQLite 以外的其他數據庫**    
> 如果你使用了 SQLite 以外的數據庫，請確認在使用之前已經創建了數據庫。你可以通過在你的數據庫交互方式命令中使用 " "命令來完成這件事情。CREATE DATABASE database_name;     
> 另外，還需要確保數據庫用戶中提供了 mysite/settings.py“創建數據庫”權限。這使得自動創建的 測試數據庫 能夠被以後的教程使用。  
> 如果你使用SQLite，那麼你不需要在使用前做任何事情——數據庫會在需要的時候自動創建。   
>    
> ---    
{: .block-tip}

### 設定時區
編輯mysite/settings.py文件之前，先設置TIME_ZONE為你自己的時間區。
```py
# mysite/setting.py

TIME_ZONE = 'Asia/Taipei'
```

### INSTALLED_APPS 介紹
另外，注意下文件上的 INSTALLED_APPS 設置項。這裡包含了會在你項目中啟動使用的所有Django應用。應用可以在多個項目中使用，你也可以打包並發布應用，讓其他人使用它。   
通常，INSTALLED_APPS 默認包包括了以下 Django 的自帶應用：    

* django.contrib.admin-- 管理員站點，你很快就會使用它。
* django.contrib.auth-- 認證授權系統。
* django.contrib.contenttypes-- 內容類框架。
* django.contrib.sessions-- 會議框架。
* django.contrib.messages-- 消息框。
* django.contrib.staticfiles-- 管理靜態文件的框架。
     
這些應用程序被默認啟用是為了給常規項目提供方便。     
默認啟動的某些應用需要至少一個數據表，所以，在使用它們之前需要在數據庫中創建一些表。請執行以下命令：     
     
```shell
$ python manage.py migrate

------
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK
```     

這個migrate命令查看INSTALLED_APPS配置，並根據 mysite/settings.py 文件中的數據庫配置和隨應用提供的數據庫遷移文件（我們將在後面介紹這些），創建任何必需的數據庫表。你會看到它應用的每一個遷移都有一個消息。如果你有興趣，運行你的數據庫命令客戶端，輸入\dt（PostgreSQL），（MariaDB，MySQL），（SQLite）或（Oracle）來顯示Django創建的表。SHOW TABLES;.tablesSELECT TABLE_NAME FROM USER_TABLES;


### 創建模型

在 Django 裡寫一個數據庫驅動的 Web 應用的第一步是確定模型 - 也就是數據庫完成設計和附加的其他元數據。


#### Question、 Choice
在這個投票應用中，需要創建兩個模型：問題 Question 和選項 Choice      
     
* Question : 模型包含問題描述和發佈時間    
* Choice : 模型有兩個單詞，選擇項目描述和當前獲得票數。每個選項屬於一個問題    
     
這些概念可以通過一個Python類來描述。點擊下面的例子來編輯polls/models.py文件：        

```py
# polls/models.py

from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

每個模型都被顯示為django.db.models.Model類的子類。每個模型都有很多類型的變化，它們都顯示模型裡的一個數據庫字符段。

每個單詞段都是Field類的實例 - 比如，單詞段被表示為CharField，日期時間段被表示為DateTimeField。這將告訴Django每個單詞段要處理的數據類。

每個Field類實例變量的名稱（例如question_text或pub_date）也是部分名稱，所以最好使用對機器友善的格式。你將在 Python 代碼裡使用它，並且數資料庫會將它們作為名單。

你可以使用可選的選項來為Field 確定一個人類可讀的名字。這個功能在很多 Django 內部組成部分中都被使用了，並且作為文檔的一部分。如果某個單詞段沒有提供此名稱，Django 將會使用對機器友善的名字，也就是變量名。在上面的例子中，我們只是為確定 Question.pub_date了對人類友善的名字。對模型內部的其他部分，它的機器友好名也會被用作人類好名使用。

確定某類Field 實例需要參數。例如CharField 需要一個max_length 參數。這個參數的使用處不止於使用來確定數據庫結構，也用於驗證數據，我們以後會看到這方面的內容。

Field 也可以接收多個可選參數；在上面的例子中：我們將的votes也default就是默認值，設為0。

注意在最後，我們使用ForeignKey確定了一個關係。這將告訴 Django，每個對像Choice都關聯到一個對象 Question 。Django 支持所有常用的數據庫關係：多對一、多對多和一對一。


### 啟動 models

上面一小段使用創建模型的代碼給了Django很多信息，通過這些信息，Django可以：

* 為這個應用創建數據庫模式（生成語言）。CREATE TABLE
* 創建可以與Question和Choice對象進行交互的 Python 數據庫 API。

但首先要把polls應用安裝到我們的項目目錄裡。

> ---        
> **設計哲學**       
> Django應用是“可插拔”的。你可以在多個項目中使用同一個應用。除此之外，你還可以發布自己的應用，因為它們並不會被綁定到當之前安裝的 Django 上。     
>    
> ---        
{: .block-tip}



為了在我們的工程中包含這個應用，我們需要在配置類INSTALLED_APPS中添加設置。因為PollsConfig類寫在文件polls/apps.py中，所以它的點式路徑是'polls.apps.PollsConfig'。在文件mysite/settings.py中子INSTALLED_APPS項添加點式路向後，它看起來像這樣：     

```py
# mysite/setting.py

INSTALLED_APPS = [
    "polls.apps.PollsConfig",           # -> 這一行
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

現在你的 Django 項目會包含polls 應用程序。繼續運行下面的命令：

```shell
$ python manage.py makemigrations polls

------
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
```

通過運行makemigrations命令，Django 會檢測你對模型文件的修改（在這種情況下，你已經取得了新的），並把修改的部分存儲為一次遷移。        
     
遷移是 Django 對模型確定義（也就是你的數據庫結構）的變化的存儲形式 - 它們實際上也只是一些你磁盤上的文件。如果你想的話，你可以閱讀一下你模型的遷移數據，它被存儲在polls/migrations/0001_initial.py裡。，你你需要每閱讀遷移遷移，但是都，但是它們設計設計設計成成人類人類人類形式的形式    
     
Django 有一個自動執行數據庫遷移並同步管理你的數據庫結構的命令 - 這個命令是migrate，我們馬上就會接觸它 - 但首先，讓我們看看遷移命令會執行哪些SQL語句。sqlmigrate 命令接收一個遷移的名稱，然後返回對應的SQL：  


#### 查看 table 表格的創建狀況 

```md
$ python manage.py sqlmigrate polls 0001
```

你會看到類似下面這樣的輸出（我把輸出重新組合成了人類可讀的格式）：

```md
> BEGIN;
> --
> -- Create model Question
> --
> CREATE TABLE "polls_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "question_text" varchar(200) NOT NULL, "pub_date" datetime NOT NULL);
> --
> -- Create model Choice
> --
> CREATE TABLE "polls_choice" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL, "question_id" bigint NOT > NULL REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED);
> CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");
> COMMIT;
```

請注意以下幾點：

* 輸出的內容和你使用的數據庫有關，上面的輸出顯示示例使用的是 PostgreSQL。
* 數據庫的表名是由應用名( polls)和模型名的字體(question 和 choice)連接而來。（如果需要，你可以自行決定這樣做。）
* 主鍵(IDs)會被自動創建。（當然，你也可以自定義。）
* 默認的，Django 會在外鍵字符段名稱後追加字符符串"_id"。（同樣，這也可以自定義。）
* 外鍵關係由生成。你不用關心部分，它只是告訴PostgreSQL，請在事務全部執行完之後再創建外鍵系。FOREIGN KEYDEFERRABLE
* 它是為你正在使用的數據庫定義的，因此特定於數據庫的字符串類型，例如“auto_increment”（MySQL）、“bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY”（PostgreSQL）或“in teger 主鍵自增” `` ( SQLite) 會自動為您處理。 段名的引用也是這樣——例如，使用雙引號或單引號。
* 這個sqlmigrate命令並沒有真正在你的數據庫中執行遷移 - 相對，它只是把命令輸出到屏幕上，讓你看Django 認為需要執行哪些SQL 語言句。這在你想看Django到底準備做什麼，或者當你是數據庫管理人員，需要寫腳本來批量處理數據庫時會很有用。

如果你感興趣，你也可以嘗試運行;這個命令幫助你檢查項目中的問題，並且並且在檢查過程中不會對數據庫進行任何操作作。python manage.py check

現在，再一次運行migrate指令，在數據庫裡創建新定義的模型的數據表：


```shell
$ python manage.py migrate

------
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying polls.0001_initial... OK
```


這個migrate命令選中所有還有沒有執行過的遷移（Django通過在數據庫中創建一個特殊的表django_migrations來跟踪執行哪些遷移）並應用在數據庫上 - 也就是將你對模型的更改同步到數據庫結構上。  
     
遷移是非常強大的功能，它可以讓你在開發過程中保持持續的修改數據庫結構而不需要重新刪除和創建 - 它專注使數資料庫平穩升級而不會丟失數據。我們會在後面的課程中更多深入的學習這部分內容，現在，你只需要記住，改變模型需要這三步：  
         
* 編輯models.py文件，修改模型。
* 運行 為模型的修改生成遷移文件。python manage.py makemigrations
* 運行 來應用數據庫遷移。python manage.py migrate
     
數據庫遷移被解析生成和應用兩個命令是為了讓你能夠在代碼控制系統上提供遷移數據並使其能夠在多個應用裡使用用；這不僅會讓開發更簡單，也給不同的開發者和生產環境中的使用帶來方便。     
通過閱讀文檔Django後台文檔，你可以獲得關於 manage.py工具的更多信息。     



### 初試API

現在讓我們進入交互方式 Python 命令行，試試下面 Django 為你創建的各種 API。通過以下命令打開 Python 命令行：

```shell
$ python manage.py shell

# Ps. 這個就相當於 rails c
```


我們使用這個指令而不是簡單的使用“python”是因為manage.py會設置DJANGO_SETTINGS_MODULE環境變化，這個變化會讓Django根據mysite/settings.py文件來設置Python包的路徑。

進入 shell 後，探索數據庫 API：

```shell
>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>
```


等等。對於我們了解了這個物件的細節沒有什麼幫助。讓我們通過編輯模型的代號（位於中）來修復這個問題。給和增加方法。     
`<Question: Question object (1)>Questionpolls/models.pyQuestionChoice__str__()`

```py
# polls/models.py

from django.db import models

class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
```

給模型增加__str__() 方法是很重要的，這不僅僅能給你在命行里使用帶來方法，Django自動生成的admin也使用這個方法來表達顯示對象。

讓我們再為這個模型添加一個自定義方法：

```py
# polls/models.py

import datetime

from django.db import models
from django.utils import timezone

class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
```

新加入的 和 分別導入了 Python 的標準 模塊和 Django 中和時區相關的工具模塊。如果你不太熟悉 Python 中的時區處理，看時區支持文檔案吧。import datetimefrom django.utils import timezonedatetimedjango.utils.timezone

保存這些更改並通過再次運行啟動一個新的 Python 交互式 shell ：python manage.py shell


```shell
$ python manage.py shell

------
>>> from polls.models import Choice, Question

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith="What")
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text="Not much", votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text="The sky", votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text="Just hacking again", votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith="Just hacking")
>>> c.delete()
```


### 介紹Django管理頁面


#### 創建一個管理員賬號

首先，我們得創建一個能登錄管理頁面的用戶。請運行下面的命令：

```shell
$ python manage.py createsuperuser

-----
Username (leave blank to use 'yee0526'): admin
Email address: admin@gmail.com
Password: 
Password (again): 
```

#### 輸入完成後，啟動開發服務器
Django 的管理界面默認就是啟動的。讓我們啟動開發服務器，看看它到底是什麼樣的。

如果打開服務器未啟動，用以下命令啟動它：
```shell
$ python manage.py runserver
```

現在，打開瀏覽器，轉到你本地名稱的“/admin/”目錄， -- 比如http://127.0.0.1:8000/admin/。你應該會看到管理員登錄界面：
因為翻譯功能可以默認是啟動的，如果你設置了LANGUAGE_CODE，登錄界面將顯示你設置的語言（如果 Django 有相應的翻譯）。


### 向管理頁面中加入投票應用

但是我們的投票應用在哪呢？它沒有在搜索頁面裡顯示。   
只需要再做一件事：我們得告訴管理，問題Question對象需要一個後台接口。打開 `polls/admin.py` 文件，把它編輯成下面這樣：     


## 投票應用 - 第三部分

### 更多的 views 頁面

現在讓我們向 polls/views.py 添加更多 views。 這些 views 略有不同，因為它們有一個引數：


```py
# polls/view

def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)


def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)


def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
```



Wire these new views into the polls.urls module by adding the following path() calls:

通過添加以下 path() 調用將這些新 `views` 連接到 polls.urls 模塊中：

```py
# polls/urls.py

from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path("", views.index, name="index"),
    # ex: /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
    # ex: /polls/5/results/
    path("<int:question_id>/results/", views.results, name="results"),
    # ex: /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
```


> ---    
> 懶人包： django 要像 ruby 那樣新增路徑     
> (1) 先到 views 增加方法，可以順便把畫面上會顯示哪些文字設定出來        
> (2) 到 urls.py 頁面把剛剛寫的方法加進來    
> (3) name="vote"，這個意思是幫路徑命名，之後其他app可以直接引用這個路徑的使用方法   
>    
> ---    
{: .block-tip}


### 路徑介紹

如果今天你想要的路徑是這樣： `/polls/34` 。 Django 會加載 `mysite.urls` 這個檔案中的 python 模組，因為它是由 `ROOT_URLCONF` 設定指向的。它會找到叫做 `urlpatterns` 的變數，並按照陣列中的順序跑遍歷一次。    


找到 `polls/` 符合項後，他會先刪除 `polls/` 的片段，並把 `34/` 這個剩下的片段，送去給 `polls.urls` 的 URLconf 去做進一步處理，而他也因為與 `'<int:question_id>/'` 相符合，所以會去呼叫 `detail()` 方法。

```md
> detail(request=<HttpRequest object>, question_id=34)
```

`question_id=34` 這一段的來由是從尖括號 `<int:question_id>` 捕捉URL的一部分來，並被視作關鍵字參數發送給 `view`。 



### 把新增的物件，印在首頁上

還記得我們前面有自己新增一個 `Question` 物件嗎？我們來把他印在 polls 首頁上：

```py
# polls/views.py

from django.http import HttpResponse
from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    output = ", ".join([q.question_text for q in latest_question_list])
    return HttpResponse(output)

# Leave the rest of the views (detail, results, vote) unchanged
```


這邊解釋一下為什麼這樣寫可以印出來：     
1. 首先用 `Question.objects.order_by("-pub_date")[:5]` 把所有 `Question` 物件，按照發佈時間順序抓出來    
2. 再來因為前面那個方法抓出來的是一個陣列，因此我們用 for 迴圈 + join 方法，把所有方法串起來     
3. 最後印出來    


不過這樣雖然印出來了，但還是碰到一個問題，就是畫面看起來太陽春，如果我們想要讓畫面變得好看，我們可以來使用 `template` 讓畫面豐富一點。   


### 創建 template 檔案

首先在 polls 資料夾下面，新增一個 `template` 資料夾，Django 會自動去這個地方尋找 `template`。    
透過 `template` 的設定，可以讓 django 知道你的畫面要長什麼樣子，像下面這樣：


```html
<!-- polls/templates/polls/index.html -->

{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```


設定好 html 的樣式後，接著來把 views 那邊設定好，讓我們來使用剛剛寫好的 template：

這樣我們就讓 views 指定的畫面，改由在 template 那邊渲染出來。


### render 用法


加載 model、填充上下文並返回帶有渲染模板結果的 HttpResponse 物件是一種非常常見的習慣用法。 Django 提供了一個快捷方式。 這是重寫後的完整 index() `view`：

```py
# polls/views.py

from django.shortcuts import render
from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    context = {"latest_question_list": latest_question_list}
    return render(request, "polls/index.html", context)

```



請注意，一旦我們在所有這些 `view` 中完成此操作 (使用 render)，我們就不再需要導入 loader 和 HttpResponse（如果您仍然擁有用於詳細信息、結果和投票的存根方法，您將需要保留 HttpResponse）。   
render() 函數將請求對像作為其第一個參數，模板名稱作為其第二個參數，字典作為其可選的第三個參數。 它返回使用給定上下文呈現的給定模板的 HttpResponse 對象。     




### 404 頁面

現在，讓我們來處理問題詳細信息視圖——顯示給定民意調查的問題文本的頁面。 這是 `view` ：


```py
from django.http import Http404
from django.shortcuts import render

from .models import Question


# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, "polls/detail.html", {"question": question})
```



### get_object_or_404() 用法

有另外一種寫法可以讓 404 更精簡：

```py
from django.shortcuts import get_object_or_404, render

from .models import Question


# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/detail.html", {"question": question})
```

get_object_or_404() 函數將 Django 模型作為其第一個參數和任意數量的關鍵字參數，並將其傳遞給模型管理器的 get() 函數。 如果該對像不存在，則會引發 Http404。


### 修改 detail 的 template


我們現在來把問題的答案給印出來，也就是我們的 choice 物件，還記得我們一開始新建 question 的設定嗎？一個 question 也會有許多的 choice，所以可以這樣設定：

```html
<!-- polls/templates/polls/detail.html -->

<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
```


### 刪除在 template 中太複雜的 URLs

記得，當我們設定連結時，有些連結的寫法可能會長得像這樣：
```html
<!-- polls/index.html -->

<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
```

這種之後如果我們要修改會有點太麻煩，所以我們用另外一種寫法，還記得我們在設定路徑的時候，有給他一個 name 的屬性嗎？像這樣：
```py
# mysite/polls/urls.py

urlpatterns = [
    # ex: /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
]
```

因此，我們的 template 可以改成這樣寫：
```html
<!-- polls/index.html -->

<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
```

這樣寫之後，雖然看起來一點都沒有變得比較簡單，但他的好處是，當你這樣寫後，他會直接去讀取你在 urlpatterns 裡面的 `path name 屬性`，也就是說，如果你今天想要改變這個頁面的路徑，改成這樣：

```py
# mysite/polls/urls.py

# old url -> polls/12/
# new url -> polls/specifics/12/

urlpatterns = [
    # ex: /polls/5/
    path("specifics/<int:question_id>/", views.detail, name="detail"),
]
```

Ps. 這個用法就跟 ROR 的 link_to 語法差不多，都是讓你之後改路徑，直接去 url.py 的地方統一改就好，不用到 html 頁面一個一個改。




### namespace 的使用

在本教學中，只有 polls 這一個 app，但是在正常的軟體中，會有幾十個apps，因此這時要如何區別每一個 app 的 name 呢？ 就要使用到 namespace 的概念了：

```py
# polls/urls.py

from django.urls import path

from . import views

app_name = "polls"                          # 這裡
urlpatterns = [
    path("", views.index, name="index"),
    path("<int:question_id>/", views.detail, name="detail"),
    path("<int:question_id>/results/", views.results, name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
```

這邊改好後，就可以到 template 改變寫法：
```html
<!-- polls/index.html -->

<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
```

這樣就可以達成 namespace 的寫法！




MVT 架構流程
------

來總結一下 MVT 流程：

### 1. 先在 model 設定物件
```py
# mysite/polls/models.py

import datetime

from django.db import models
from django.utils import timezone


# Create your models here.
class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")
    
    def __str__(self):
        return self.question_text  
    
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)      

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
    def __str__(self):
        return self.choice_text    
```
### 2. 添加進 install app

```py
# mysite/setting.py

INSTALLED_APPS = [
    "polls.apps.PollsConfig",           # -> 這一行
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

### 3. make migration

現在你的 Django 項目會包含polls 應用程序。繼續運行下面的命令：

```shell
$ python manage.py makemigrations polls
```

### 4. views 設定路徑

```py
# polls/views.py

from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    template = loader.get_template("polls/index.html")
    context = {
        "latest_question_list": latest_question_list,
    }
    return HttpResponse(template.render(context, request))
```


### 5. 設定 Template 的 HTML 樣式
```html
<!-- polls/templates/polls/index.html -->

{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
```


-------------
-------------
-------------



























### 建立應用程式 - python3 manage.py startapp 'app name'
打上這個指令後，會新增一個 blog 資料夾
```shell
$ (virtualenv) (base) yeedeAir:mytestsite yee0526$ python3 manage.py startapp blog
```

打上這個指令後，會新增一個 catalog 資料夾

```shell
$ (virtualenv) (base) yeedeAir:mytestsite yee0526$ python3 manage.py startapp catalog
```


```md
djangogirls
├── mytestsite
|       __init__.py
|       settings.py
|       urls.py
|       wsgi.py
├── manage.py
└── blog
|       admin.py
|       apps.py
|       models.py
|       tests.py
|       views.py
|       __init__.py
|       migrations/    
|
└── catalog
|       admin.py
|       apps.py
|       models.py
|       tests.py
|       views.py
|       __init__.py
|       migrations/                
```


### 註冊應用 

既然應用已經創建好了，我們還必須在項目裡註冊它，以便工具在運行時它會包括在裡面（比如在數據庫裡添加模型時）。在項目的 settings 裡，把應用添加進INSTALLED_APPS ，就完成了註冊。

打開項目設置文件 mytestsite/mytestsite/settings.py找到 INSTALLED_APPS 列表裡的定義。如下所示，在列表的最後添加新的一行。

#### 原始 code

```py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",    
]
```

#### 註冊 code

```py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    'catalog.apps.CatalogConfig',
]
```


### 連結 URL 映射器

在項目文件夾裡，創建網站時同時生成了 URL 映射器（urls.py）。儘管你可以用它來管理所有對應的 URL ，但是更常用的做法是把 URL 對應留到它們相關的應用中。

打開 mytestsite/mytestsite/urls.py 注意指導文字解釋了一些使用 URL 映射器的方法。







