---
title: Docker
author: YeeChen
date: 2022-12-13
category: Rails
layout: post
---


> ---    
> **前情提要：**         
> 如果今天想要對google登入或者facebook登入，做popup頁面  
> 也就是點擊登入按鈕後，不是進入特定頁面，而是彈出一個視窗出來，這樣怎麼做呢？
>    
> ---    
{: .block-tip}




Docker 介紹
------


Docker 基礎架構
------

### Docker Daemon

Docker Daemon 負責監聽 Docker API 的請求，並且管理 Docker 的物件，像是映像檔(image)、容器(Container)、虛擬網路(Network)以及Volume，還可以和其他的 Docker Daemon 進行通訊，管理 Docker 整體服務。

### Docker Client

Docker Client 是大部分用戶和 Docker 互動的主要方式，當你使用 docker container run 指令的時候，Client 就會將這段指令透過 REST API 發送給 Docker Daemon，並由其執行背後程序，一個 Client 可以和一個以上的 Daemon 通訊。 

### Docker Registries

Docker Registries 是專門儲存映像檔的倉庫，DockerHub 則是任何人都可以用的公共倉庫(像是 GitHub )，Docker 本身預設就是在 DockerHub 上面尋找映像檔。

你也可以建立自己的私人倉庫，來存放屬於公司內部或是屬於自己的映像檔。當你使用 `docker pull` 或是 `docker container run` 指令時，所需的映像檔就會從設定好的倉庫中拉出，當你使用 `docker push` 指令時，映像檔就會被推送到你設定的倉庫中，沒有設定的情況下，倉庫都預設為 「DockerHub」


Docker 物件
------

因為 docker 就像樂高一樣，所以用物件來說明蠻適當的。先介紹一下有哪些物件

(1) 映像檔 - image
(2) 容器 - container
(3) 容積 - volume
(4) 虛擬網路 - networks


### 映像檔 image

映像檔本身是一個唯讀的樣板，搭配一長串的指令，在大部分情況下，一個映像檔是基於另外一個映像檔(大部分是使用官方映像檔)，並加上額外的一椰參數所建立。

舉例來說，你可以建立一個 Ubuntu 的映像檔，在裡面利用指令安裝任何你需要的套件，像是 VIM、GIT 等等，並打包成自己的映像檔，執行成容器時，就會有 VIM、GIT等套件的功能。

當然你也可以做專屬於你的映像檔，或是使用別人發佈在DockerHub上的映像檔，但要記得挑選有認證的，以防安全問題。

如果你要寫只屬於自己的映像檔，需要撰寫 `Dockerfile` ，後面會提到怎麼寫，利用一些語法來定義映像檔，以及執行成容器所需的步驟與工具。


### 容器 container

容器是映像檔的運作實體，可以透過 Docker Client 發送 API 來啟動、暫停、刪除容器，也可以將一個容器連接到一個以上的虛擬網路，甚至根據其當前的狀態，建制一個新的映像檔。

預設情況下，一個容器和其他容器及主機是相對隔離的，但可以透過控制容器的虛擬網路，來把其他容器加入相同的網路，改變之間的隔離程度。



### 容積 volume

volume 是一個非常重要的物件，本身運作於容器之外，確保容器刪除後的資料保存，而 volume 是儲存在主機上的，和容器本身的生命週期無關，這讓使用者可以輕鬆地在各個容器間共享檔案系統。

volume 有兩種使用方式，分別是 Volume 和 Bind Mount(掛載)，後面會說到。


### 虛擬網路 networks

Docker 強大的原因，在於容器間可以互相溝通，並將服務串連，亦或是將他們連接到非 Docker 的執行環境，容器本身甚至不需要知道自己是否被部署在 Docker 上面，都是靠著虛擬網路達成連線的功能。



Docker 指令格式
------


首先我們直接在終端機輸入 docker
```shell
$ docker

-------
Usage:  docker [OPTIONS] COMMAND
A self-sufficient runtime for containers

Options:
.....

Management Commands:
.....

Commands:
.....
```

主要會看到這幾個資訊：

### options 

options 主要是一些 Docker 的全域設定


### Management

我們用 `docker container run` 指令來解說：


```shell

$ docker container run ...

# 上面的 container 是被操作的物件，也就是 Management Command
# run 則是對物件進行操作，也就是 Command
```

Management Command 本身是可以被操作的 Docker 物件，Command 則是對該物件的執行動作，上面的例子就是執行一個容器。


```shell

$ docker network create ...

# network 是被操作的物件，也就是 Management Command
# create 則是對物件進行操作，也就是 Command
```

上面的例子就是建立一個虛擬網路


### docker helper

如果今天忘記一些指令，可以這樣輸入，這樣會有一大堆提示、該輸入哪些參數可以看
```shell
$ docker container run --help

-------
Usage:  docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
Run a command in a new container
Options:
.....
```


容器生命週期
------


### 啟動容器

```shell
$ docker container run --publish 80:80 nginx

------
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
ebc3dc5a2d72: Pull complete 
b8dc57082e5d: Pull complete 
0c203f625277: Pull complete 
5ff69ab3adbc: Pull complete 
......
```

### 退出非背景執行容器

按下 `Ctrl + C` ， 就可以退出容器



### 列出執行中的容器

```shell
$ docker container list

------
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS         PORTS                    NAMES
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago   Up 6 minutes   0.0.0.0:3306->3306/tcp   summary-interview-db-1
```

Ps. 如果今天退出所有 docker 的話，這邊會是空的

### 列出包含退出狀態的容器

```shell
$ docker container list --all

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS         PORTS                    NAMES
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago   Up 6 minutes   0.0.0.0:3306->3306/tcp   summary-interview-db-1
02ab51e1fc28   nginx          "/docker-entrypoint.…"   About a minute Exited (0) ..                           cool_clarke
.....

```

### 啟動退出狀態的容器

如果今天容器是在退出狀態，我們不需要使用run，直接用start指令就好

```shell
$ docker container start {CONTAINER ID}

ex. docker container start 19f0b
```


### 退出背景執行的容器

如果今天是使用start來啟動容器，會發現用 Ctrl + c 會無法退出容器，因此要用這個指令來退出

```shell
$ docker container stop 02ab51e1fc28
```

### 刪除退出狀態的容器

刪除容器有兩種方法  

#### 先介紹如何刪除進入退出狀態的容器
```shell
$ docker container rm 02ab51e1fc28
```


#### 強制刪除容器

如果今天容器還在執行狀態，使用剛剛的刪除方法，會發現他不給你刪除，因此要改成這樣刪除

```shell
$ docker container rm --force 02ab51e1fc28
```


### 背景執行容器

一開始有提到，我們可以用 `docker container run` 來執行容器，那要怎麼在一開始執行容器的時候，就讓容器進入背景執行狀態呢？
```shell
$ docker container run --publish 80:80 --detach nginx
```



### 替容器命名

如果我們不替容器命名的話，每次產生的容器ID都是亂數產生的，這樣有點難精準控制我想要的容器，因此我們可以幫容器取名

```shell
$ docker container run --name good --publish 80:80 --detach nginx
```

這邊我們產生了一個叫做 `good` 的容器，我們來看看是否有生成這個容器

```shell
$ docker container list

------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
f3bdbfbdbf14   nginx          "/docker-entrypoint.…"   8 seconds ago   Up 7 seconds    0.0.0.0:80->80/tcp       good
```


接著我們前面操作(停下、刪除)都是用容器ID來執行，現在我們用容器名字就可以達成了
```shell
# 停下容器
$ docker container stop good

# 刪除容器
$ docker container rm good  
```


### 觀看容器內的LOGS

如果今天容器是在背景執行，會看不到LOGS，因此我們可以這樣輸入來看LOGS：
```shell
$ docker container logs good
```
不過這樣只能單純把LOGS印出來，如果在開發時，想要持續追蹤LOGS發展，要這樣輸入：
```shell
$ docker container logs --follow good
```

進到這個狀況的時候，如果想要離開，只要按下 Ctrl + C 就可以離開。



### 啟動容器發生了什麼事

當我們在一開始輸入指令

```shell
$ docker container run --name good --publish 80:80 --detach nginx 
------
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
```

啟動nginx的時候，電腦就可以連上localhost了，究竟電腦做了哪些事情？

```md
這一行說明了，Docker在本地端找不到nginx:latest這個映像檔
> Unable to find image 'nginx:latest' locally

所以從 library/nginx 這裡拉取映像檔，也就是從預設的 DockerHub 拉取此檔案到本地端
> latest: Pulling from library/nginx
```


### 列出容器時的所有資訊

我們前面把所有容器列出來，有顯示很多資訊，我們來看一下細節
```shell
$ docker container list

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
f3bdbfbdbf14   nginx          "/docker-entrypoint.…"   8 seconds ago   Up 7 seconds    0.0.0.0:80->80/tcp       good
```
(1) CONTAINER ID : 執行容器時，Docker 會賦予容器一個獨一無二的ID   
(2) IMAGE : 啟動時，指令中所指定的映像檔名稱   
(3) COMMAND : 容器啟動時的啟動指令，之後提到 `DOCKER映像檔` 時，會有更詳細的講解   
(4) CREATED : 何時啟動的容器   
(5) STATUS : 總共有 created、restarting、running、removing、paused、excited、dead等七種狀態，就是目前容器的狀態
(6) PORTS : 啟動時，指令中指定容器的PORT該對應到本機的哪個PORT
(7) NAMES : 容器名稱，如果沒取名，DOCKER會隨機分配取名


### 如何重新啟動容器，而不要在背景執行

我們剛剛用start開啟已經存在的容器時，系統會預設用背景執行
```shell
$ docker container start good
```

那要怎麼樣開啟時，想要直接顯示LOGS呢？我們可以用attach的方式
```shell
$ docker container start --attach good
```


### 容器生命週期演練


1. 在背景執行三個不同的服務，分別是nginx、postgres、httpd(apache)，並且分別給容器命名
2. nginx 要執行在 80:80、postgres 要執行在 5432:5432、httpd 要執行在 8080:80
3. 當啟動 postgres 容器時，需要給予環境變數 --env POSTGRES_PASSWORD=mysecretpassword，才能正確啟動
4. 使用 docker container logs 指令，來確認服務有正常啟動
5. 停止並刪除三個容器
6. 用 docker container list --all 確認所有都刪掉


```shell
$ docker container run --name good --publish 80:80 --detach nginx
$ docker container run --name bad --publish 5432:5432 --env POSTGRES_PASSWORD=mysecretpassword --detach postgres
$ docker container run --name normal --publish 8080:80 --detach httpd
```

查看該docker的log
```shell
$ docker container logs bad

$ docker container logs --follow bad
```


停止這個docker
```shell
$ docker container stop bad
```


刪除這個docker
```shell
$ docker container rm bad
```

一探容器內部
------

### 透過指令進步內部

透過下方的指令，我們會從一個終端機，進到另一個終端機，輸入後，我們會看到這個東西

```shell
$ docker container run --interactive --tty nginx bash
----

root@7b6dcbac069a:/# 
```

#### 可以再#號後面輸入Linux指令試試
```shell
root@7b6dcbac069a:/# ls

-----
bin  boot  dev	docker-entrypoint.d  docker-entrypoint.sh  etc	home  lib  media  mnt  opt  proc  root	run  sbin  srv	sys  tmp  usr  var
```




#### 離開容器內部
```shell
root@7b6dcbac069a:/# exit
```



### 進入運行中的容器

先確認有想進入的容器有沒有在運行(mystifying_ganguly這個有在進行)
```shell
$ docker container list

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
7b6dcbac069a   nginx          "/docker-entrypoint.…"   4 minutes ago   Up 11 seconds   80/tcp                   mystifying_ganguly
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago    Up 25 hours     0.0.0.0:3306->3306/tcp   summary-interview-db-1
```

對於正在運作中的容器，我們要輸入 `exec` 指令，才能進入
```shell
$ docker container exec --interactive --tty 7b6dcbac069a bash
```

這樣就可以進入正在運作的容器中，並且一樣可以執行指令

```shell
root@7b6dcbac069a:/# ls
bin  boot  dev	docker-entrypoint.d  docker-entrypoint.sh  etc	home  lib  media  mnt  opt  proc  root	run  sbin  srv	sys  tmp  usr  var

root@7b6dcbac069a:/# exit
exit
```

### 新參數介紹

#### --interactive : keep STDIN open even if not attached

直接翻譯的意思是， `保持輸入模式` ，可以理解成容器之間保持互動狀態

#### --tty : Allocate a pseudo-TTY

直接翻譯的意思是， `分配一個虛擬的TTY` ，那TTY是什麼？   
由於古早的電腦非常貴，一台電腦要分配給很多個電腦操作，當多個用戶自然會需要多台打字機對電腦進行輸入，TTY就是 `Teletypewriter` 的縮寫，簡單來說可以簡單地把終端機想像成TTY。   


#### exec 

exec是一個允許在執行中的 Docker 容器執行任何指令的指令，白話一點來說，就是他可以把指令傳遞到執行中的容器內，並要求容器執行指令。

#### bash

我們先用下這一行指令，這樣可以看到run後面可以接哪些參數  
這樣我們會發現 `IMAGE` 後面可以接 COMMAND 的參數，這個 COMMAND 就是容器執行後，會執行的指令  
```shell
$ docker container run --helper

-------
Usage:  docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
```


不過我們先來看之前寫的這一行
```shell
$ docker container run --interactive --tty nginx bash
```



為什麼我們之前寫的是 bash，這是因為映像檔在建置的時候，都會給一個CMD參數來當作容器啟動時的指令，若沒有額外輸入COMMAND，就會使用映像檔預設的啟動指令。  
而預設的 nginx 指令就是 `nginx -g daemon off` -> 這一行是啟動nginx的意思。   
  
而這邊我們改成用 `bash` 取代 `nginx -g daemon off` 這一串啟動指令，變成容器在啟動時，執行bash這個命令處理器。



### 在容器安裝套件

先產生一個新的 `ubuntu container` 並先離開
```shell
$ docker container run --interactive --tty --name ubuntu ubuntu

$ root@7a206a77f57d:/# exit
```

再來我們重新啟動 container
```shell
$ docker container start --interactive ubuntu
```

接著我們來安裝curl工具，並且測試容器是否會保存我們安裝的東西
```shell
$ root@7a206a77f57d:/# apt install -y curl

------
Reading package lists... Done
Building dependency tree... Done
...略
```

離開 container
```shell
$ root@7a206a77f57d:/# exit
```

因為離開了，所以容器現在是退出狀態，接著我們再次啟動ubuntu容器，如果curl可以使用，代表容器是有保存的功能

```shell
$ docker container start --interactive ubuntu
```



如果今天在docker遇到ubuntu安裝curl的問題，像下面這樣
```md
apt-get install curl

Reading package lists... Done
Building dependency tree       
Reading state information... Done
E: Unable to locate package curl
```

解決方法輸入這個就可以 - It is because there is no package cache in the image, you need to run:

```shell
$ apt-get update
```

解決連結 - https://stackoverflow.com/questions/27273412/cannot-install-packages-inside-docker-ubuntu-image



確定安裝好curl之後，就可以先離開container，再進去之後，輸入
```shell
$ root@7a206a77f57d:/# curl google.com 

------
<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>
```

如果有成功叫出HTML檔案，代表docker確實有保存安裝的插件



容器與虛擬機
------


### 什麼是虛擬機

理論上的說法是，在電腦上透過 `Hypervisor` 的軟體，將作業系統和硬體與應用程式分開，這樣就可以將自己劃分為數個獨立的 `虛擬機器`。

白話一點的說法是，可以想像成一個管家(Hypervisor)，幫你把一個房子分成好幾間套房，每一個套房都有自己的衛浴設備和供電設施，誰也不求誰，但還是佔掉整個房子的容積
，而且像是水龍頭的流水量，也因為多條水管牽線導致流水量不順暢。


虛擬機佔據的硬體比較多，啟動速度也比較慢，是因為每個虛擬機都可以獨立執行自己的作業系統和應用程式，同時還可以分配到從 `Hypervisor` 所管理的原始資源。
這些資源包括記憶體、RAM、儲存設備...等。


```md
> 虛擬機示意圖


-------------------  -------------------  -------------------
| Virtual Machine |  | Virtual Machine |  | Virtual Machine |
|-----------------|  |-----------------|  |-----------------|
|   App A         |  |   App B         |  |   App C         |
|-----------------|  |-----------------|  |-----------------|
|                 |  |                 |  |                 |
|   Guest         |  |   Guest         |  |   Guest         |
|   Operating     |  |   Operating     |  |   Operating     |
|   System        |  |   System        |  |   System        |
|                 |  |                 |  |                 |
|-----------------|  |-----------------|  |-----------------|

-------------------------------------------------------------
|                                                           |
|                  Hypervisor                               |
|                                                           |
|-----------------------------------------------------------|

|-----------------------------------------------------------|
|                                                           |
|                  Infrastructure                           |
|                                                           |
|-----------------------------------------------------------|
```


### 什麼是容器

容器其實就是一個抽象的應用層，把程式碼和相依套件打包在一起，多個容器可以在同一台機器上運作，並且和其他容器共享作業系統的核心(這和虛擬機完全不同)。   
虛擬機是每一個都有自己的作業系統，容器在Linux作業系統上作為獨立的執行程序相較於虛擬機，能夠佔用更少的空間，又能夠處理更多的應用程式。    


```md
> 容器示意圖


|----------| |----------| |----------| |----------| |----------|
|          | |          | |          | |          | |          |
|          | |          | |          | |          | |          |
|   App A  | |   App B  | |   App C  | |   App D  | |   App E  |
|          | |          | |          | |          | |          |
|----------| |----------| |----------| |----------| |----------|
  

----------------------------------------------------------------
|                                                              |
|                  Docker                                      |
|                                                              |
|---------------------------------------------------------------
|--------------------------------------------------------------|
|                                                              |
|                  Host Operating System                       |
|                                                              |
|---------------------------------------------------------------

|---------------------------------------------------------------
|                                                              |
|                  Infrastructure                              |
|                                                              |
|---------------------------------------------------------------
```





> ---    
> Docker 容器只是在 Linux 作業系統上的執行程序，並不是什麼迷你的虛擬機   
> 他能夠獲取的資源有限，在程序結束時，容器就會進入退出的狀態     
>    
> ---    
{: .block-tip}



### docker 容器只是在 Linux 作業系統上的執行程序

為了驗證 docker 只是一個在Linux 作業系統上的執行程序，我們先來啟動一個容器

```shell
$ docker container start ubuntu
```

再來使用top，來查看該容器的執行程序
```shell
# 這個指令的意思是，列出該容器的所有執行程序，可以看到列出的PID，也就是執行程序本身的ID
$ docker container top ubuntu

---------
UID            PID              PPID             C                STIME            TTY              TIME             CMD
root           2244             2217             0                10:25            ?                00:00:00         /bin/bash
```


那要怎麼驗證容器本身只是一個 Linux 作業系統上的執行程序呢？我們可以在 Linux 作業系統的終端機輸入 `ps aux` (列出系統所有執行程序資料)
這樣會看到容器內的PID和Linux作業系統的PID相同，這樣就可以驗證，其實 Docker 是跑在 Linux 的作業系統上，並非虛擬機的概念
如果今天是虛擬機，在當前的作業系統，是看不到執行程序的！

### 為什麼只提 Linux

會一直提 Linux 的原因，是因為 Mac 和 Windows 上的 Docker，是執行在迷你虛擬機上，所以當你在上述兩者作業系統中，列出所有執行程序，是沒辦法看到容器的執行程序

那要如何在 mac 上看到容器的執行序呢？我們需要先連上迷你的虛擬機，只要按照下方的指令，就可以看到虛擬機內的執行程序：
```shell
$ docker run -it --rm --privileged --pid=host justincormack/nsenter1
```

容器的IP和PORT
------




### 檢查容器的PORT

```shell
# 先在背景啟動一個nginx
$ docker container run --detach --publish 80:80 --name nginx nginx  

# 查看port
$ docker container port nginx

-------
80/tcp -> 0.0.0.0:80
```


### 0.0.0.0 和 127.0.0.1 在 Docker 中有哪裡不一樣

在 docker container port 回應中有看到 `0.0.0.0:80` ，這是因為容器本身沒有設定 IP 位置， Docker 預設為 `0.0.0.0`，和我們一般本機開發的 `127.0.0.1` 不太一樣，這代表什麼呢？

在 docker 世界， `127.0.0.1` 代表 `這個容器的本身`，而不是 `這台機器`，如果從一個容器向外連接到 `127.0.0.1` ，對於容器本身來說就像連到自己一樣。

如果今天有兩個容器要互相溝通，不小心把容器綁定成 `127.0.0.1` ，會沒辦法向外溝通，而 `0.0.0.0` 代表網路街口，他能接受來自其他容器的連接，以及外部的連接都能成功到達容器內。


### 容器的IP位置


我們前面都還沒談論過容器的IP位置，或許你會認為容器和主機都以相同的IP的位置執行，但其實不是，我們可以透過docker container inspect 指令來看到容器的 IP 位置：
```shell
$ docker container inspect --format '{{ .NetworkSettings.IPAddress }}' nginx

------
172.17.0.3
```

### 接著查看本機的IP位置

inet 10.8.8.147，這一段就是我們的本機IP位置

```shell
$ ifconfig en0

-------
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	options=6463<RXCSUM,TXCSUM,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM>
	ether 1c:57:dc:45:4b:19 
	inet6 fe80::18ea:d978:4c81:d9ea%en0 prefixlen 64 secured scopeid 0xc 
	inet 10.8.8.147 netmask 0xffffff00 broadcast 10.8.8.255
	nd6 options=201<PERFORMNUD,DAD>
	media: autoselect
	status: active
```


Ps. 因此可以確定，本機和容器的IP位置是不同的



Docker 虛擬網路
------

### 電腦防火牆

防火牆一開始的意思，是古人使用木頭建造房屋時，為了避免火災蔓延，將堅固的石塊堆砌在房屋周圍作為屏障。     
而現代網路的意意思，是指隔離本機網路，與外界網路的一道防禦系統，藉由控制過濾限制訊息，來保護內部網路資料的安全。   

Ps. 防火牆預設阻止所有從網際網路中進來的流量，提到防火牆，就是希望透過著方式更理解Docker如何向網際網路打開大門，並讓外部請求進到容器內部。



### 打開防火牆

正常情況下，Docker預設會用一個叫做 `bridge` 的虛擬網路，我們可以透過以下指令來看：

```shell
$ docker network list

-------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
65abba938f22   external-service-network   bridge    local
86299be73d50   host                       host      local
bd3c20ec4d10   none                       null      local
```

這個虛擬網路幫我們橋接了本機的網路介面，讓我們可以透過簡單的 --publish 參數，快速啟動容器，並對應到防火牆該開啟哪個port。
若是沒有指定虛擬網路的情況下，Docker會預設使用這個 `bridge` 的虛擬網路，



這裡剛好可以提到，為什麼nginx的容器預設不會被分配到和本機相同的IP位置呢？
因為沒有指定網路的話，容器會以Docker的bridge虛擬網路優先，並連接上去，所以當然不同的網路環境會顯示不同的IP位置




我們可以透過以下指令，查看bridge這個虛擬網路的IP：


```shell
$ docker network inspect bridge

------
[
    {
        "Name": "bridge",
        "Id": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "Created": "2023-04-19T10:18:50.301027583Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        ......省略
    }
]
```


可以發現這一行："Gateway": "172.17.0.1"，還記得我們前面查看的nginx IP是多少嗎？
```shell
$ docker container inspect --format '{{ .NetworkSettings.IPAddress }}' nginx

------
172.17.0.3
```


就像前面說的一樣，沒有指定虛擬網路的情況下，Docker 預設使用bridge這個虛擬網路，而Docker則替我們在bridge網路內分配IP位置。
但是即使容器被分配到不同的IP位置，這又和網際網路的請求，能夠進入容器內部有什麼關係呢？



### NAT 網路位址轉換

Docker 透過 `NAT` 這項技術讓外部的請求進入 Docker，並順著虛擬網路找到容器。


NAT 這項技術被廣泛用在許多公司的內部網路，或是私人企業的內網中，主要原因是IPv4的位置稀少，很多企業或網路公司在只有少數的IP位置情況下，公司內部卻有太多電腦要連接網路，故採取共用IP的解決方法，就是讓一個IP位置給多台電腦使用。


使用者上網後，拿到一個IP位置，而IP分享器或無線基地台，則將一組專門給內部使用的私有IP分配給所有的內部電腦，內部每台電腦擁有一個 `192.168.0.X` 的IP位置，但無線基地台對外卻只有一個由網路公司賦予的IP位置。


通常，NAT將每一部電腦所用的IP，對應到共用IP，且NAT負責將進出封包的HEADER進行轉換，使得內部電腦可以輕鬆的用外部網路連線溝通。


用上述的概念，我們可以想像Docker本身就是負責分配IP的機器，而在Docker上運作的容器都是公司內部的電腦，被分配一個IP位置，但主要外面的入口還是要通過Docker來處理底層的網路技術。



### 操作 Docker 虛擬網路

#### list 指令

```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bd3c20ec4d10   none                       null      local
```

如果沒有特別建立虛擬網路的話，一開始應該只會看到這幾個虛擬網路。

(1) 第一個 bridge 是我們前面介紹 Docker 預設的虛擬網路，藉由 NAT 技術潛伏在主機的防火牆後方
(2) 第二個是 HOST 虛擬網路，這是一個特殊的服務，他跳過了 Docker 的虛擬網路，直接把容器連接到主機的網路介面上，這麼做有好處、也有壞處。壞處是安全性降低了，好處是可以提高網路的效能
(3) 最後一個是 none 虛擬網路，連到這個虛擬網路 = 沒有連到任何虛擬網路，有時候我們想要斷開某些曝光在網路的服務，可以暫時先將容器連接到 none 虛擬網路。


#### inspect 指令

`inspect` 是一個非常萬用的指令，不論搭配Docker哪先物件，都可以使用inspect指令來查看資訊

```shell
$ docker network inspect bridge   

------
[
    {
        "Name": "bridge",
        "Id": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "Created": "2023-04-19T10:18:50.301027583Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "42c5762b9b63674ff28ebb2021d2f3b2b0d341f14017943fa8f470ac3c046709": {
                "Name": "nginx",
                "EndpointID": "c431653f7de60d8e4ed823e5e243f4f8dcd3c21dae5d892029aaf8f77a6f5767",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            },
            "7a206a77f57dbff19428b8fa7b2f44639d138560607fbf30358bd5039a706084": {
                "Name": "ubuntu",
                "EndpointID": "d630a41211bca33964c600481f69610e65971a5b25e058383259ff325f2f18bf",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        ......省略
]
```

上面可以看到，Containers裡面有兩個容器連在bridge這個虛擬網路上。

### 建立自己的虛擬網路

app中的名字，可以取自己喜歡的
```shell
$ docker network create {app}

ex. docker network create newNetwork
```

在把list列出來，會發現剛剛新創的虛擬網路有在裡面
```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bfad8604bfd2   newNetwork                 bridge    local
bd3c20ec4d10   none                       null      local
```



### 添加原先的容器到虛擬網路中


如果我們想要把先前創建的容器，新增到剛剛創的虛擬網路，要怎麼做呢？使用 `--network 參數`

```shell
# 先清除舊有的所有容器
$ docker container rm --force $(docker container list --all --quiet)

# 新增一個容器
$ docker container run --detach --publish 80:80 --network {app} --name nginx nginx
------
4b4cd504eca96331f4c1740ff5fe906bd15031800817970c35a979fa8d2ca4d1
```

接著我們來確認一下剛剛那個指令，我們有沒有把容器連上剛剛創的虛擬網路
```shell
$ docker network inspect newNetwork

------
[
    {        
        ...省略
        "Containers": {
            "4b4cd504eca96331f4c1740ff5fe906bd15031800817970c35a979fa8d2ca4d1": {
                "Name": "nginx",
                "EndpointID": "f742988d816920ec25db21a6a6d5922b9e3b0a34a4e7ce61a1c732e948b13e50",
                "MacAddress": "02:42:ac:13:00:02",
                "IPv4Address": "172.19.0.2/16",
                "IPv6Address": ""
            }
        },
        ...省略

    }
]

```

確實有連上虛擬網路！但是在食物上，我們會需要替正在運作的容器，加進新的虛擬網路，這時候中斷容器服務，再重新使用 `--network` 的方式不太合理。


### 添加運作中的容器到新的虛擬網路


先新增一個postgres容器，並且讓他連接到預設bridge網路
Ps. 什麼都不設定，就是連到bridge
```shell
$ docker container run --detach --name pg --env POSTGRES_PASSWORD=password postgres
```

接著吧PG虛擬網路，跟剛剛新創的虛擬網路連接上去
Ps. 這個指令不會有反應，因為他沒有response
```shell
# newNetwork是虛擬網路的name，pg是容器的name
$ docker network connect newNetwork pg
```

那我們要怎麼驗證，這個容器有同時連接到兩個虛擬網路呢？一樣使用inspect就好了
```shell
$ docker container inspect pg

------
"Networks": {
    "bridge": {
        "IPAMConfig": null,
        "Links": null,
        "Aliases": null,
        "NetworkID": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "EndpointID": "c793fb4e1580a8f443a076502b81fad38852fd1b649bab122ac44e720a5395f8",
        "Gateway": "172.17.0.1",
        "IPAddress": "172.17.0.2",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "MacAddress": "02:42:ac:11:00:02",
        "DriverOpts": null
    ,
    "newNetwork": {
        "IPAMConfig": {},
        "Links": null,
        "Aliases": [
            "fe3ee07b5174"
        ],
        "NetworkID": "bfad8604bfd275abf2c53a0a04074bd9f3d1c6876b539bbef5cc73ef1f11a6a2",
        "EndpointID": "ce8f04560baa29bf8e983e440fda8389ab9a06591bae63e03a8d135f73b0c7e3",
        "Gateway": "172.19.0.1",
        "IPAddress": "172.19.0.3",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "MacAddress": "02:42:ac:13:00:03",
        "DriverOpts": {}
```



這樣看此容器確實有連接到兩個虛擬網路！

### 中斷虛擬網路的連接

此指令可以中斷容器和虛擬網路的連接
Ps. 一樣不會有response
```shell
$ docker network disconnect newNetwork pg
```

### driver 是什麼

我們在列出虛擬網路的list時候，會發現有一個DRIVER的欄位
```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bfad8604bfd2   newNetwork                 bridge    local
bd3c20ec4d10   none                       null      local
```

看到上面的資料應該會覺得有一個地方很神奇，就是 `newNetwork` 也就是我們新創的虛擬網路，他的 `DRIVER` 也是用 `bridge`。
原因就是如果今天沒有指定driver的話，docker預設的driver就是bridge。

使用bridge當作driver的虛擬網路，通常適用在單主機的容器們需要互相溝通的情況。為什麼強調是單主機呢？因為後面會提到另外一個driver，就是 `overlay`，這種虛擬網路可以跨平台溝通。


Docker 的 DNS
------

在 docker 的世界，我們可以忘掉IP位置這件事情，因為前面提到過，容器的IP會由Docker做分配，每次容器啟動的時機不同，都會導致IP位置不一樣，所以想要透過IP位置來做容器間的相互溝通，是不太實際的。

因此DNS就是Docker的解決方案，當我們對一個容器命名後(--name)，在Docker虛擬網路中，我們為他的命名就是這跟服物的DNS，我們可以透過他的名字，訪問到容器。


### 用 IP 位置來溝通

我們先清空所有容器
```shell
$ docker container rm --force $(docker container list --all --quiet)
```

#### 創建第一個container
最後一個參數後面才會提到，先不用理會
```shell
$ docker container run --publish 3000:3000 --detach  --name whoami --network newNetwork robeeerto/whoami
```

上面輸入好後，我們打開瀏覽器，並輸入 `http://localhost:3000/` 後，會看到下面的資訊
```md
> 容器名稱：a9292f6ceb25
> 容器的 IP 位置：172.19.0.2
> 環境變數 AUTHOR 是：robertchang
```

這裡的容器名稱，就是我們剛剛新啟動容器的ID，而IP位置就是Docker幫容器分配的IP位置，第三個嘖IMAGE才會提到

#### 創建第二個container



```shell
$ docker container run --publish 3001:3000 --detach  --name whoami-2 --network newNetwork robeeerto/whoami
```

上面輸入好後，我們打開瀏覽器，並輸入 `http://localhost:3001/` 後，會看到下面的資訊

```md
> 容器名稱：b129236860f0
> 容器的 IP 位置：172.19.0.3
> 環境變數 AUTHOR 是：robertchang
```


現在，我們新創的虛擬網路 `newNetwork`，有兩個容器連上去了(whoami、whoami-2)，接著我們來讓兩個容器進行溝通，這邊我們先用IP位置的方法進行溝通：

Ps. 使用curl工具

```shell
# 先進去第一個容器
$ docker container exec --interactive --tty whoami sh
```

進入第一個容器的環境後，輸入下面這行
```md
> /app # curl 172.19.0.3:3000

------
> 容器名稱：b129236860f0<br>容器的 IP 位置：172.19.0.3<br>環境變數 AUTHOR 是：robertchang/app # 
```

會發現有成功溝通了，但是我們今天試試不同的流程看看，也就是重新把剛剛的流程重走一次，並且這一次要在中間穿插一個服務


#### (1) 先清空容器
```shell
$ docker container rm --force $(docker container list --all --quiet)
```

#### (2) 新增一個whoami容器

```shell
$ docker container run --publish 3000:3000 --detach --name whoami --network newNetwork robeeerto/whoami
```

#### (3) 新增一個postgres容器

```shell
$ docker container run --detach --name pg --env POSTGRES_PASSWORD=password --network newNetwork postgres
```

#### (4) 新增一個whoami-2容器

```shell
$ docker container run --publish 3001:3000 --detach --name whoami-2 --network newNetwork robeeerto/whoami
```


現在 `newNetwork` 虛擬網路中，有三個容器了，並且我們在兩個中間穿插了一個PG容器，現在我們再來試試用IP位置進行容器溝通

(1) 先進到第一個容器中
```shell
$ docker container exec --interactive --tty whoami sh
```
(2) 溝通到whoami-2容器
```md
> /app # curl 172.19.0.3:3000

------
> curl: (7) Failed to connect to 172.19.0.3 port 3000 after 5 ms: Connection refused 
```

輸入同樣的IP位置後，會發現whoami-2的IP位置變了，因為這個IP位置已經被PG拿走。


### 用 DNS 來溝通

以剛剛的當作範例，我們直接透過DNS來進行溝通

(1) 先進到第一個容器中
```shell
$ docker container exec --interactive --tty whoami sh
```

(2) 溝通到whoami-2容器
```md
> /app # curl whoami-2:3000

------
> 容器名稱：c442b528e93f<br>容器的 IP 位置：172.19.0.4<br>環境變數 AUTHOR 是：robertchang/app # 
```

會發現用DNS溝通可以成功！


### 為什麼是 port 3000

有注意到的人應該會很好奇，明明前面我們新增容器的時候，whoami-2的port明明是-publish 3001:3000，但是為啥我們剛剛由容器1，溝通到容器2的指令是curl 172.19.0.3:3000。     

首先我們可以回想一下，左邊的port代表的是什麼意思，代表的是這台機器上對應的port，而不是容器本身打開的port 3001:3000，以這個例子來說，機器上打開3001，但容器本身還是3000。     


而假設今天在相同的虛擬網路，whoami容器要找到whoami-2容器，並不需要進到網際網路，再回到虛擬網路中，而是直接通過容器本身所在的虛擬網路內的容器名稱(DNS)，，加上打開的PORT進行連線即可。


### 為什麼不用 bridge Network 呢

如果今天不指定虛擬網路的話，Docker 不是預設會以 bridge 的虛擬網路為主嗎？為什麼還要特地自己建立虛擬網路呢？
因為預設的 bridge 虛擬網路沒有內建 Docker DNS 功能，所以若是使用預設的虛擬網路，會發現剛剛用 DNS 連線的範例是連線不到 whoami-2 的。


### 使用 --link 方式讓兩個容器在預設的虛擬網路做溝通

現在我們不要讓兩個容器在我們剛剛新建的虛擬網路內，而是讓兩個在預設的虛擬網路內


```shell
# 第一個容器
$ docker container run --publish 3000:3000 --detach --name whoami robeeerto/whoami

# 第二個容器使用--link
$ docker container run --publish 3001:3000 --detach --name whoami-2 --link whoami robeeerto/whoami
```

再來進到容器二裡面
```shell
$ docker container exec --interactive --tty whoami-2 sh

------
/app # curl whoami:3000
容器名稱：fcce7320b68f<br>容器的 IP 位置：172.17.0.2<br>環境變數 AUTHOR 是：robertchang/app # 
```

這樣確實成功讓容器一和容器二互相溝通




Docker 映像檔
------

什麼是 `映像檔`，簡單來說，就是 `Docker執行容器時的說明書，並附上工具包的一個檔案`。
映像檔本身是透過一個叫做 `Dockerfile` 的檔案建製而成，而在 `Dockerfile` 中，我們可以一步步告訴Docker：「黑！照著這些步驟去執行，中間有些必要的套件是必要的，幫我在執行容器時，一起放進去吧！」。
映像檔不一定是一個作業系統，他只是單純在作業系統上的執行程序。

映像檔可以非常的迷你，小到只是一個檔案，像是 `Golang` 的應用程式在編譯完後，就是一個靜態的執行檔案。他也可以非常巨大，像是完整的 Ubuntu 作業系統，或是 PHP 的執行環境等。

### 從 DockerHub 認識映像檔


#### docker official image 

官方把映像檔放在DockerHub上，其目的是提供基本的作業系統(例如：Ubuntu、CentOS)或服務(例如：postgreSQL、redis等)，希望可以作為大多數使用者的起點，也為現在流行的程式語言提供類似
「平台即服務」的概念，像是「Ruby、Golang、Node」等，都有官方認可的映像檔。


官方映像檔也同時是Dockerfile的最佳實踐範例，提供非常清楚的說明，讓其他使用者在撰寫Dockerfile的時候，有一個很好的參考，也確保安全性和更新速度，這非常重要，因為官方映像檔基本就是DockerHub上最受歡迎的映像檔。



#### verified publisher

為所有開發者提供官方的驗證，這些映像檔來自可信賴的來源，減少了從不安全的儲存褲中拉取危險映像檔的風險，基本上只要有這個徽章，就是可信賴又安全的映像檔，也可以透過嚴格的安全審查害DockerHub官方申請這個徽章。

### 映像檔標籤

我們進到DockerHub後，點選Redis，可以看到裡面有滿滿的版本、作業系統的後綴。

這邊要提到一個慣例，就是如果沒有指定要下載哪個版本，通常會拉 `latest` 的版本下來，那要如何拉指定版本呢？

我們來使用下列的指令，並且在指令最後加上標籤號：

```shell
$ docker image pull redis:7.0
```


那我們現在拉一個7.0.4版本
```shell
$ docker image pull redis:7.0.4
```

我們執行這個指令的時候，會發現一件事，就是下載速度超級快，這是怎麼回事呢？我們打開映像檔看看

```shell
$ docker image list

------
REPOSITORY               TAG       IMAGE ID       CREATED        SIZE
redis                    7.0       84ed4fbf28f6   6 days ago     111MB
redis                    7.0.4     84ed4fbf28f6   7 months ago   111MB
```


會發現兩個 `IMAGE ID` 完全相同，因為這兩個是同一份映像檔，只是用不同的標籤顯示而已，這才觸發了Docker的快取機制，導致根本沒有下載的感覺，因為畚箕已經有一份一樣的映像檔了。   
至於雖然兩個映像檔都是111MB，但是實際容量不是222，而是111，因為這兩個標籤都指向同一個映像檔，所以不會額外佔據本機空間。  


標籤最大的作用是 `穩定版本`，如果今天只有 `latest` 時，對於正式環境很不可靠，永遠都要擔心版本更換的時候，正是版本會不會有問題。



### 怎麼到處都有 alpine

如果是剛學習docker的新手，會常常聽到「alpine」這個名詞，這其實就是Linux的一個分支，和Ubuntu、CentOS是一樣的，那為啥在Docker世界中，alpine的討論度會這麼高呢？    
最大原因在於他非常小！我們來下載redis的alpine看看

```shell
$ docker image pull redis:7-alpine

------
REPOSITORY               TAG       IMAGE ID       CREATED        SIZE
redis                    7.0       84ed4fbf28f6   6 days ago     111MB
redis                    7.0.4     84ed4fbf28f6   7 months ago   111MB
redis                    7-alpine   d196fde608b2   6 days ago     30.4MB
```

列出來之後，會發現alpine的容量超級小，小也有小的犧牲，很多基主的套件在alpine是沒有提供的，如果需要要自己去安裝

### 層層堆疊的映像檔

透過以下指令，我們來查看層層堆疊的映像檔是什麼概念！

```shell
$ docker image history nginx:latest

------
IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT
9e7e7b26c784   12 days ago   /bin/sh -c #(nop)  CMD ["nginx" "-g" "daemon…   0B        
<missing>      12 days ago   /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B        
<missing>      12 days ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        
<missing>      12 days ago   /bin/sh -c #(nop)  ENTRYPOINT ["/docker-entr…   0B        
<missing>      12 days ago   /bin/sh -c #(nop) COPY file:e57eef017a414ca7…   4.62kB    
<missing>      12 days ago   /bin/sh -c #(nop) COPY file:abbcbf84dc17ee44…   1.27kB    
<missing>      12 days ago   /bin/sh -c #(nop) COPY file:5c18272734349488…   2.12kB    
<missing>      12 days ago   /bin/sh -c #(nop) COPY file:7b307b62e82255f0…   1.62kB    
<missing>      12 days ago   /bin/sh -c set -x     && addgroup --system -…   60.6MB    
<missing>      12 days ago   /bin/sh -c #(nop)  ENV PKG_RELEASE=1~bullseye   0B        
<missing>      12 days ago   /bin/sh -c #(nop)  ENV NJS_VERSION=0.7.11       0B        
<missing>      12 days ago   /bin/sh -c #(nop)  ENV NGINX_VERSION=1.23.4     0B        
<missing>      12 days ago   /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B        
<missing>      12 days ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B        
<missing>      12 days ago   /bin/sh -c #(nop) ADD file:7b3c55926db26568f…   74.3MB  
```


可以發現每一個映像層，由下而上堆積起來，到最後形成一個映像檔，並且賦予ID - 9e7e7b26c784，這個歷史紀錄不是來自容器的歷史紀錄，而是這個映像檔案在建置時候的歷史紀錄，
在每一層都帶有不同的指令，有些是執行指令，有些是加入檔案，所以才會有0B的層級，也有74.3MB的層級。



### 映像檔快取的秘密

在映像檔中都有獨一無二的SHA所計算出來的ID，目的是幫助Docker去辨認是否已經有一樣的映像層。



### 自製一個帶有PHP程式語言環境的映像檔

Step1: 我們使用PHP的映像檔當做基底

```md
> 自製映像檔第一層

> |---------------------------------------------------------------
> |                                                              |
> |                           PHP                                |
> |                                                              |
> |--------------------------------------------------------------- 
```

Step2:撰寫Dockerfile。在這個第一層的PHP之上增加新的映像層，像是加入環境變數，或是COPY本機的資料到映像檔內等。

```md
> 堆疊而成的映像檔

> |---------------------------------------------------------------         
> |                                                              |  ------ |
> |                           COPY                               |         | 
> |                                                              |         |
> |---------------------------------------------------------------         |
> |---------------------------------------------------------------         |
> |                                                              |         | 
> |                           ENV                                |         |==> 自製映像檔
> |                                                              |         |
> |---------------------------------------------------------------         |
> |---------------------------------------------------------------         |
> |                                                              |         |
> |                           PHP                                |         |
> |                                                              |         |
> |---------------------------------------------------------------  ------ |
```

Step3: 我們想要做另外一個以PHP為基礎的映像檔，而Docker會用到前面提過的SHA創造的獨特ID，辨識出已經有相同的PHP映像檔在本機之中，並利用其已經存在的特性加快映像檔的建置，也一併減少整體電腦耗費的硬體容量，這是Docker最基本的快取機制。


```md
> 共用相同映像檔的兩個映像檔

> |--------------------------| |---------------------------------|
> |                          | |                                 | 
> |     COPY Staging         | |   COPY PRODUCTION               |  
> |                          | |                                 | 
> |--------------------------| |---------------------------------|
> |---------------------------------------------------------------
> |                                                              |
> |                           Port80                             | 
> |                                                              |
> |---------------------------------------------------------------
> |---------------------------------------------------------------
> |                                                              |
> |                           Nginx                              |
> |                                                              |
> |---------------------------------------------------------------
> |---------------------------------------------------------------
> |                                                              |
> |                           自製映像檔                           |
> |                                                              |
> |---------------------------------------------------------------
```


對上面的ENV、COPY、RUN指令不熟悉沒關係，先了解到映像檔是透過一層一層的映像層堆疊而成，而每個指令都會形成一個映像層，這是很重要的概念，之後會反覆利用這個概念來加快建置的速度和大小。



### 對相同應用程式建置兩個不同的映像檔

再舉一個例子，相同的一個應用程式可能會因為部署的環境不同，而分成Staging(接近正式)、Production(正式)兩種版本，並使用COPY指令來複製不同的設定檔案，進而建置兩個不同的映像檔。

```md
> Docker的快取特性

>                   |--------------------------| |---------------------------------|        
>                   |                          | |                                 |        
>            | ---  |          COPY            | |             EXPOSE              |  ---   | 
>            |      |                          | |                                 |        |
>            |      |--------------------------| |---------------------------------|        |
>            |      |--------------------------| |---------------------------------|        |
>            |      |                          | |                                 |        |
>  image1 == |      |           ENV            | |              RUN                |        |  == image2
>            |      |                          | |                                 |        |
>            |      |--------------------------| |---------------------------------|        |
>            |      |---------------------------------------------------------------        |
>            |      |                                                              |        | 
>            | ---  |                           PHP                                |  ---   | 
>                   |                                           基礎映像檔共用       |        
>                   |---------------------------------------------------------------
```


### 映像檔歷史紀錄中的missing

透過快取的機制更了解映像檔後，根據下圖由下往上看，就像是 `docker image history` 一樣，每一個歷史紀錄都代表了一個映像層，我們也可以透過歷史紀錄看到每一層最後一次更動的時間是啥時。   
而最前面的missing其實不是錯誤訊息，也不是有什麼檔案缺失，只是這些都同屬於一個映像檔的一部分，但又礙於ID並不是每一個映像層都需要，才用這種方式顯示。


```md
> 歷史紀錄示意圖

>            |---------------------------------------------------------------    
>            |                                                              |   
>  b459081   |                           Port80                             | -- |
>            |                                                              |    |
>            |---------------------------------------------------------------    |
>            |---------------------------------------------------------------    |
>            |                                                              |    |
>  missing   |                           Nginx                              |    | ====== 映像檔
>            |                                                              |    |
>            |---------------------------------------------------------------    |
>            |---------------------------------------------------------------    |
>            |                                                              |    |
>  missing   |                           自製映像檔                           |    |
>            |                                                              | -- |
>            |---------------------------------------------------------------





### 映像檔的唯讀性 

映像檔本身是唯讀的，意思是我們沒辦法更動映像檔內部的檔案系統，不過還記得前面我們曾經在容器裡面安裝 `Curl` 這個套件嗎？為啥會說不能更動呢？這邊我就要提到 `可寫層` 了！


### 可寫層

Docker 在容器啟動的時候，多加了一層可寫層在映像檔上方，所有對於檔案系統的更動都會記錄在可寫層上，且會隨著容器的刪除一起消失，若是更改的內容涉及映像檔原先擁有的檔案，Docker則會在可寫層上採用COPY、Write的方式，使得映像檔最初的檔案系統依舊保持一致，這麼做的理由很簡單，若是每次使用映像檔都會使其檔案系統受到污染，那就會大幅降低共同使用的方便性，啟動速度也會大幅降低


```md
> 利用可寫層來保持唯讀性

> |---------------------------------------------------------------     
> |                                                              |     
> |                           可寫層                              | <---｜
> |                                                              |     ｜
> |---------------------------------------------------------------     ｜  啟動容器時會加入一層可寫層
> |---------------------------------------------------------------     ｜
> |                                                              |     ｜
> |                           映像檔                              | ----｜  
> |                                                              |  
> |---------------------------------------------------------------  
```


### 檢視image細節

我們用 `inspect` 這個指令，來查看image的細節

```shell
$ docker image inspect nginx

------
    {
        ...省略

        "ExposedPorts": {
            "80/tcp": {}
        },
        
        ...省略

        "Env": [
            "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
            "NGINX_VERSION=1.23.4",
            "NJS_VERSION=0.7.11",
            "PKG_RELEASE=1~bullseye"
        ],
        "Cmd": [
            "/bin/sh",
            "-c",
            "#(nop) ",
            "CMD [\"nginx\" \"-g\" \"daemon off;\"]"
        ],
        "Image": "sha256:563125e602b67b1bbea9ae27e43ad6312d3243ff15aa7f498d20e5b189f59fa8",
        "Volumes": null,
        "WorkingDir": "",
        "Entrypoint": [
            "/docker-entrypoint.sh"
        ],

        ,,,省略

        "Os": "linux",


```


由於內容太多，我們只提幾個要注意的
#### (1) ExposedPorts

可以得知映像檔在建置的時候，便已經設好PORT了，這也是為什麼前面在操作容器的時候，我們不會動到右邊的PORT，因為如果更動的話，會和映像檔設定的不同，造成服務對不上
#### (2) ENV環境變數
他就是我們在建置映像檔的時候就可以放進去的變數，當我們啟動容器時，內部就會擁有這些環境變數。

我們來做個測試，先進入nginx執行的容器，並呼叫環境變數：

```shell
$ docker container run --interactive --tty nginx bash
---

root:/# echo $NGINX_VERSION

> 1.23.4
```
  

#### (3) CMD這一段 -> Docker 容器的啟動指令

這裡預設是啟動nginx的服務，回到前面說過的「唯讀性」，我們做的這些改變並不會影響到nginx映像檔本身，即使替換了啟動指令，也都是在可寫層做變化。     
利用 `docker image inspect` 指令查看到的映像檔，本身也沒有任何變化。     


#### (4) OS - Linux
最後是作業系統，可以看到這裡被設計執行在 Linux 上的作業系統，也呼應前面說的，macOS本身也是運行一個迷你的虛擬機還執行Docker，所以這裡看到的是Linux，而不是macOS


### 推送映像檔到 DockerHub

先在腦中的認知，映像檔應該要長這樣，先用nginx來示範

> ---
> nginx:latest #映像檔的名稱：標籤      
>    
> ---
{: .block-ip}



接下來要在這個映像檔前面加上儲存庫的名稱，告訴他主要存到哪一個儲存庫之中，我們先打開映像檔列表，就可以看到從左至右分別是儲存酷的「名稱」、「標籤」、「映像檔ID」、「建立時間」、「大小」：
```shell
$ docker image list

------
REPOSITORY               TAG        IMAGE ID       CREATED        SIZE
redis                    7-alpine   d196fde608b2   7 days ago     30.4MB
nginx                    latest     9e7e7b26c784   13 days ago    135MB
redis                    7.0.4      f36d9597bf44   7 months ago   111MB
robeeerto/whoami         latest     3f1e79a452a0   5 months ago   276MB
```


上面「robeeerto/whoami」明顯跟其他人不一樣，，前面有提到說，官方的映像檔事沒有前綴的，而斜線前面的名稱，是dockerhub登入後右上角的名稱。
那要怎麼改變映像檔的名字呢？可以用docker image tag指定，把nginx:latest貼上一個不同的標籤：

```shell
$ docker image tag nginx:latest robeeerto/nginx:latest
```

Ps. 沒有反應是正常的

此時我們再看一次list，會發現貼標籤不會動映像檔做任何改動，可以看到除了名字，其他TAG、ID...等等都是一樣的
```shell
$ docker image list

------
REPOSITORY               TAG        IMAGE ID       CREATED        SIZE
redis                    7-alpine   d196fde608b2   7 days ago     30.4MB
nginx                    latest     9e7e7b26c784   13 days ago    135MB
robeeerto/nginx          latest     9e7e7b26c784   13 days ago    135MB
robeeerto/whoami         latest     3f1e79a452a0   5 months ago   276MB
```

最後我們把剛剛貼上標籤的nginx推上DockerHub

```shell
$ docker image push robeeerto/nginx:latest

------
The push refers to repository [docker.io/robeeerto/nginx]
ce6504827299: Preparing 
cbd644319450: Preparing 
7577f7ad3cd4: Preparing 
4bdc748e7c3d: Preparing 
c607b6f95cf7: Preparing 
0b9f60fbcaf1: Waiting 
denied: requested access to the resource is denied
```


不過會發現，被拒絕了，這是因為權限問題，我們先登入一下

### 用終端機登入DockerHub

```shell
$ docker login

------
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: YeeeChen
Password: 
Error response from daemon: Get "https://registry-1.docker.io/v2/": unauthorized: incorrect username or password
```

但是我們遇到了這個問題，這個原因是因為要申請個人的Token，因此我們現在到官網來申請：

依照此步驟：登入官網後，點擊右上角大頭貼，點擊「Account Setting」-> 點擊左邊「Security」 -> 點擊中間的「New Access Token」-> 填寫Token名稱 -> 點擊「Generate」，最後會跳出一個畫面，只要依照上面步驟在終端機輸入，就可以成功用終端機登入DockerHub了！

(1) Run `docker login -u yeeechen`
(2) At the password prompt, enter the personal access token.(貼上剛剛Token產生的密碼)

```shell
$ docker login -u yeeechen
Password: 

------
Password: 
Login Succeeded

Logging in with your password grants your terminal complete access to your account. 
For better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/
```


這樣我們就成功用終端機登入了，讓我們繼續來推上映像檔上去

### 推送映像檔

```shell
$ docker image push robeeerto/nginx:latest
```
這樣推送會錯誤喔！還記得前面輸的，/前面代表的是自己帳戶的名稱，所以這個標籤要改成自己DockerHub的名稱，因此我現在來新增一個我自己的標籤
```shell
$ docker image tag nginx:latest yeeechen/nginx:latest

------
The push refers to repository [docker.io/yeeechen/nginx]
ce6504827299: Mounted from library/nginx
cbd644319450: Mounted from library/nginx
7577f7ad3cd4: Mounted from library/nginx
4bdc748e7c3d: Mounted from library/nginx
c607b6f95cf7: Mounted from library/nginx
0b9f60fbcaf1: Mounted from library/postgres
latest: digest: sha256:2d7084857d5435dbb3468426444a790a256409885ab17c0d3272e8460e909d3c size: 1570
```

Ps. 雖然我的官網名稱是YeeeChen，但是因為指令標籤不能有大寫，因此要都改成小寫喔



DockerHub從另一個儲存庫 `library/nginx` 分享了映像層給我們，這樣做可以大幅減少 DockerHub 在儲存映像檔的容量問題，同時也能加快推送的速度。    
另外，上方的輸出還透露了另外一個訊息就是「官方映像檔並非真的沒有前綴，而是不顯示而已」，這裡確定有看到前綴是library了，代表他們屬於library這個儲存庫     




### 映像檔完全名稱

我們在推送映像檔的時候，會注意到有一行寫著：
```md
> The push refers to repository [docker.io/yeeechen/nginx]
```

後面的yeeechen/nginx說過了，那docker.io呢？這其實是DockerHub儲存庫的網域名稱，所以下方這段才是映像檔的全名：
```md
> docker.io/yeeechen/nginx
```



### 本地建立映像檔儲存庫

先來執行下面這一段：
```shell
$ docker run --detach --publish 5000:5000 --name registry --env REGISTRY_STORAGE_DELETE_ENABLED=true registry:2

------
Unable to find image 'registry:2' locally
2: Pulling from library/registry
547446be3368: Pull complete 
5145a9c19e2a: Pull complete 
9b36e14ae70d: Pull complete 
5fa9326efe1e: Pull complete 
544654b4f256: Pull complete 
Digest: sha256:8c51be2f669c82da8015017ff1eae5e5155fcf707ba914c5c7b798fbeb03b50c
Status: Downloaded newer image for registry:2
dbbe638afbcd8e3d7ade936b3abba50ff320fae913275afa5caa0f28165db63b
docker: Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:5000 -> 0.0.0.0:0: listen tcp 0.0.0.0:5000: bind: address already in use.
```

這樣我們就在本地端執行了一個映像檔儲存庫，讓我們試著把剛才重新貼標籤的映像檔再換一個新標籤
```shell
$ docker image tag yeeechen/nginx:latest localhost:5000/yeeechen/nginx:latest
```

接著把他推到本地執行起來的映像檔儲存庫內：
```shell
$ docker image push localhost:5000/yeeechen/nginx:latest 
```








