---
title: Docker
author: YeeChen
date: 2022-12-13
category: Rails
layout: post
---


> ---    
> **前情提要：**         
> 如果今天想要對google登入或者facebook登入，做popup頁面  
> 也就是點擊登入按鈕後，不是進入特定頁面，而是彈出一個視窗出來，這樣怎麼做呢？
>    
> ---    
{: .block-tip}




Docker 介紹
------


Docker 基礎架構
------

### Docker Daemon

Docker Daemon 負責監聽 Docker API 的請求，並且管理 Docker 的物件，像是映像檔(image)、容器(Container)、虛擬網路(Network)以及Volume，還可以和其他的 Docker Daemon 進行通訊，管理 Docker 整體服務。

### Docker Client

Docker Client 是大部分用戶和 Docker 互動的主要方式，當你使用 docker container run 指令的時候，Client 就會將這段指令透過 REST API 發送給 Docker Daemon，並由其執行背後程序，一個 Client 可以和一個以上的 Daemon 通訊。 

### Docker Registries

Docker Registries 是專門儲存映像檔的倉庫，DockerHub 則是任何人都可以用的公共倉庫(像是 GitHub )，Docker 本身預設就是在 DockerHub 上面尋找映像檔。

你也可以建立自己的私人倉庫，來存放屬於公司內部或是屬於自己的映像檔。當你使用 `docker pull` 或是 `docker container run` 指令時，所需的映像檔就會從設定好的倉庫中拉出，當你使用 `docker push` 指令時，映像檔就會被推送到你設定的倉庫中，沒有設定的情況下，倉庫都預設為 「DockerHub」


Docker 物件
------

因為 docker 就像樂高一樣，所以用物件來說明蠻適當的。先介紹一下有哪些物件

(1) 映像檔 - image
(2) 容器 - container
(3) 容積 - volume
(4) 虛擬網路 - networks


### 映像檔 image

映像檔本身是一個唯讀的樣板，搭配一長串的指令，在大部分情況下，一個映像檔是基於另外一個映像檔(大部分是使用官方映像檔)，並加上額外的一椰參數所建立。

舉例來說，你可以建立一個 Ubuntu 的映像檔，在裡面利用指令安裝任何你需要的套件，像是 VIM、GIT 等等，並打包成自己的映像檔，執行成容器時，就會有 VIM、GIT等套件的功能。

當然你也可以做專屬於你的映像檔，或是使用別人發佈在DockerHub上的映像檔，但要記得挑選有認證的，以防安全問題。

如果你要寫只屬於自己的映像檔，需要撰寫 `Dockerfile` ，後面會提到怎麼寫，利用一些語法來定義映像檔，以及執行成容器所需的步驟與工具。


### 容器 container

容器是映像檔的運作實體，可以透過 Docker Client 發送 API 來啟動、暫停、刪除容器，也可以將一個容器連接到一個以上的虛擬網路，甚至根據其當前的狀態，建制一個新的映像檔。

預設情況下，一個容器和其他容器及主機是相對隔離的，但可以透過控制容器的虛擬網路，來把其他容器加入相同的網路，改變之間的隔離程度。



### 容積 volume

volume 是一個非常重要的物件，本身運作於容器之外，確保容器刪除後的資料保存，而 volume 是儲存在主機上的，和容器本身的生命週期無關，這讓使用者可以輕鬆地在各個容器間共享檔案系統。

volume 有兩種使用方式，分別是 Volume 和 Bind Mount(掛載)，後面會說到。


### 虛擬網路 networks

Docker 強大的原因，在於容器間可以互相溝通，並將服務串連，亦或是將他們連接到非 Docker 的執行環境，容器本身甚至不需要知道自己是否被部署在 Docker 上面，都是靠著虛擬網路達成連線的功能。



Docker 指令格式
------


首先我們直接在終端機輸入 docker
```shell
$ docker

-------
Usage:  docker [OPTIONS] COMMAND
A self-sufficient runtime for containers

Options:
.....

Management Commands:
.....

Commands:
.....
```

主要會看到這幾個資訊：

### options 

options 主要是一些 Docker 的全域設定


### Management

我們用 `docker container run` 指令來解說：


```shell

$ docker container run ...

# 上面的 container 是被操作的物件，也就是 Management Command
# run 則是對物件進行操作，也就是 Command
```

Management Command 本身是可以被操作的 Docker 物件，Command 則是對該物件的執行動作，上面的例子就是執行一個容器。


```shell

$ docker network create ...

# network 是被操作的物件，也就是 Management Command
# create 則是對物件進行操作，也就是 Command
```

上面的例子就是建立一個虛擬網路


### docker helper

如果今天忘記一些指令，可以這樣輸入，這樣會有一大堆提示、該輸入哪些參數可以看
```shell
$ docker container run --help

-------
Usage:  docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
Run a command in a new container
Options:
.....
```


容器生命週期
------


### 啟動容器

```shell
$ docker container run --publish 80:80 nginx

------
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
ebc3dc5a2d72: Pull complete 
b8dc57082e5d: Pull complete 
0c203f625277: Pull complete 
5ff69ab3adbc: Pull complete 
......
```

### 退出非背景執行容器

按下 `Ctrl + C` ， 就可以退出容器



### 列出執行中的容器

```shell
$ docker container list

------
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS         PORTS                    NAMES
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago   Up 6 minutes   0.0.0.0:3306->3306/tcp   summary-interview-db-1
```

Ps. 如果今天退出所有 docker 的話，這邊會是空的

### 列出包含退出狀態的容器

```shell
$ docker container list --all

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS         PORTS                    NAMES
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago   Up 6 minutes   0.0.0.0:3306->3306/tcp   summary-interview-db-1
02ab51e1fc28   nginx          "/docker-entrypoint.…"   About a minute Exited (0) ..                           cool_clarke
.....

```

### 啟動退出狀態的容器

如果今天容器是在退出狀態，我們不需要使用run，直接用start指令就好

```shell
$ docker container start {CONTAINER ID}

ex. docker container start 19f0b
```


### 退出背景執行的容器

如果今天是使用start來啟動容器，會發現用 Ctrl + c 會無法退出容器，因此要用這個指令來退出

```shell
$ docker container stop 02ab51e1fc28
```

### 刪除退出狀態的容器

刪除容器有兩種方法  

#### 先介紹如何刪除進入退出狀態的容器
```shell
$ docker container rm 02ab51e1fc28
```


#### 強制刪除容器

如果今天容器還在執行狀態，使用剛剛的刪除方法，會發現他不給你刪除，因此要改成這樣刪除

```shell
$ docker container rm --force 02ab51e1fc28
```


### 背景執行容器

一開始有提到，我們可以用 `docker container run` 來執行容器，那要怎麼在一開始執行容器的時候，就讓容器進入背景執行狀態呢？
```shell
$ docker container run --publish 80:80 --detach nginx
```



### 替容器命名

如果我們不替容器命名的話，每次產生的容器ID都是亂數產生的，這樣有點難精準控制我想要的容器，因此我們可以幫容器取名

```shell
$ docker container run --name good --publish 80:80 --detach nginx
```

這邊我們產生了一個叫做 `good` 的容器，我們來看看是否有生成這個容器

```shell
$ docker container list

------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
f3bdbfbdbf14   nginx          "/docker-entrypoint.…"   8 seconds ago   Up 7 seconds    0.0.0.0:80->80/tcp       good
```


接著我們前面操作(停下、刪除)都是用容器ID來執行，現在我們用容器名字就可以達成了
```shell
# 停下容器
$ docker container stop good

# 刪除容器
$ docker container rm good  
```


### 觀看容器內的LOGS

如果今天容器是在背景執行，會看不到LOGS，因此我們可以這樣輸入來看LOGS：
```shell
$ docker container logs good
```
不過這樣只能單純把LOGS印出來，如果在開發時，想要持續追蹤LOGS發展，要這樣輸入：
```shell
$ docker container logs --follow good
```

進到這個狀況的時候，如果想要離開，只要按下 Ctrl + C 就可以離開。



### 啟動容器發生了什麼事

當我們在一開始輸入指令

```shell
$ docker container run --name good --publish 80:80 --detach nginx 
------
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
```

啟動nginx的時候，電腦就可以連上localhost了，究竟電腦做了哪些事情？

```md
這一行說明了，Docker在本地端找不到nginx:latest這個映像檔
> Unable to find image 'nginx:latest' locally

所以從 library/nginx 這裡拉取映像檔，也就是從預設的 DockerHub 拉取此檔案到本地端
> latest: Pulling from library/nginx
```


### 列出容器時的所有資訊

我們前面把所有容器列出來，有顯示很多資訊，我們來看一下細節
```shell
$ docker container list

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
f3bdbfbdbf14   nginx          "/docker-entrypoint.…"   8 seconds ago   Up 7 seconds    0.0.0.0:80->80/tcp       good
```
(1) CONTAINER ID : 執行容器時，Docker 會賦予容器一個獨一無二的ID   
(2) IMAGE : 啟動時，指令中所指定的映像檔名稱   
(3) COMMAND : 容器啟動時的啟動指令，之後提到 `DOCKER映像檔` 時，會有更詳細的講解   
(4) CREATED : 何時啟動的容器   
(5) STATUS : 總共有 created、restarting、running、removing、paused、excited、dead等七種狀態，就是目前容器的狀態
(6) PORTS : 啟動時，指令中指定容器的PORT該對應到本機的哪個PORT
(7) NAMES : 容器名稱，如果沒取名，DOCKER會隨機分配取名


### 如何重新啟動容器，而不要在背景執行

我們剛剛用start開啟已經存在的容器時，系統會預設用背景執行
```shell
$ docker container start good
```

那要怎麼樣開啟時，想要直接顯示LOGS呢？我們可以用attach的方式
```shell
$ docker container start --attach good
```


### 容器生命週期演練


1. 在背景執行三個不同的服務，分別是nginx、postgres、httpd(apache)，並且分別給容器命名
2. nginx 要執行在 80:80、postgres 要執行在 5432:5432、httpd 要執行在 8080:80
3. 當啟動 postgres 容器時，需要給予環境變數 --env POSTGRES_PASSWORD=mysecretpassword，才能正確啟動
4. 使用 docker container logs 指令，來確認服務有正常啟動
5. 停止並刪除三個容器
6. 用 docker container list --all 確認所有都刪掉


```shell
$ docker container run --name good --publish 80:80 --detach nginx
$ docker container run --name bad --publish 5432:5432 --env POSTGRES_PASSWORD=mysecretpassword --detach postgres
$ docker container run --name normal --publish 8080:80 --detach httpd
```

查看該docker的log
```shell
$ docker container logs bad

$ docker container logs --follow bad
```


停止這個docker
```shell
$ docker container stop bad
```


刪除這個docker
```shell
$ docker container rm bad
```

一探容器內部
------

### 透過指令進步內部

透過下方的指令，我們會從一個終端機，進到另一個終端機，輸入後，我們會看到這個東西

```shell
$ docker container run --interactive --tty nginx bash
----

root@7b6dcbac069a:/# 
```

#### 可以再#號後面輸入Linux指令試試
```shell
root@7b6dcbac069a:/# ls

-----
bin  boot  dev	docker-entrypoint.d  docker-entrypoint.sh  etc	home  lib  media  mnt  opt  proc  root	run  sbin  srv	sys  tmp  usr  var
```




#### 離開容器內部
```shell
root@7b6dcbac069a:/# exit
```



### 進入運行中的容器

先確認有想進入的容器有沒有在運行(mystifying_ganguly這個有在進行)
```shell
$ docker container list

-------
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS                    NAMES
7b6dcbac069a   nginx          "/docker-entrypoint.…"   4 minutes ago   Up 11 seconds   80/tcp                   mystifying_ganguly
19f0b5256750   mariadb:10.4   "docker-entrypoint.s…"   2 months ago    Up 25 hours     0.0.0.0:3306->3306/tcp   summary-interview-db-1
```

對於正在運作中的容器，我們要輸入 `exec` 指令，才能進入
```shell
$ docker container exec --interactive --tty 7b6dcbac069a bash
```

這樣就可以進入正在運作的容器中，並且一樣可以執行指令

```shell
root@7b6dcbac069a:/# ls
bin  boot  dev	docker-entrypoint.d  docker-entrypoint.sh  etc	home  lib  media  mnt  opt  proc  root	run  sbin  srv	sys  tmp  usr  var

root@7b6dcbac069a:/# exit
exit
```

### 新參數介紹

#### --interactive : keep STDIN open even if not attached

直接翻譯的意思是， `保持輸入模式` ，可以理解成容器之間保持互動狀態

#### --tty : Allocate a pseudo-TTY

直接翻譯的意思是， `分配一個虛擬的TTY` ，那TTY是什麼？   
由於古早的電腦非常貴，一台電腦要分配給很多個電腦操作，當多個用戶自然會需要多台打字機對電腦進行輸入，TTY就是 `Teletypewriter` 的縮寫，簡單來說可以簡單地把終端機想像成TTY。   


#### exec 

exec是一個允許在執行中的 Docker 容器執行任何指令的指令，白話一點來說，就是他可以把指令傳遞到執行中的容器內，並要求容器執行指令。

#### bash

我們先用下這一行指令，這樣可以看到run後面可以接哪些參數  
這樣我們會發現 `IMAGE` 後面可以接 COMMAND 的參數，這個 COMMAND 就是容器執行後，會執行的指令  
```shell
$ docker container run --helper

-------
Usage:  docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
```


不過我們先來看之前寫的這一行
```shell
$ docker container run --interactive --tty nginx bash
```



為什麼我們之前寫的是 bash，這是因為映像檔在建置的時候，都會給一個CMD參數來當作容器啟動時的指令，若沒有額外輸入COMMAND，就會使用映像檔預設的啟動指令。  
而預設的 nginx 指令就是 `nginx -g daemon off` -> 這一行是啟動nginx的意思。   
  
而這邊我們改成用 `bash` 取代 `nginx -g daemon off` 這一串啟動指令，變成容器在啟動時，執行bash這個命令處理器。



### 在容器安裝套件

先產生一個新的 `ubuntu container` 並先離開
```shell
$ docker container run --interactive --tty --name ubuntu ubuntu

$ root@7a206a77f57d:/# exit
```

再來我們重新啟動 container
```shell
$ docker container start --interactive ubuntu
```

接著我們來安裝curl工具，並且測試容器是否會保存我們安裝的東西
```shell
$ root@7a206a77f57d:/# apt install -y curl

------
Reading package lists... Done
Building dependency tree... Done
...略
```

離開 container
```shell
$ root@7a206a77f57d:/# exit
```

因為離開了，所以容器現在是退出狀態，接著我們再次啟動ubuntu容器，如果curl可以使用，代表容器是有保存的功能

```shell
$ docker container start --interactive ubuntu
```



如果今天在docker遇到ubuntu安裝curl的問題，像下面這樣
```md
apt-get install curl

Reading package lists... Done
Building dependency tree       
Reading state information... Done
E: Unable to locate package curl
```

解決方法輸入這個就可以 - It is because there is no package cache in the image, you need to run:

```shell
$ apt-get update
```

解決連結 - https://stackoverflow.com/questions/27273412/cannot-install-packages-inside-docker-ubuntu-image



確定安裝好curl之後，就可以先離開container，再進去之後，輸入
```shell
$ root@7a206a77f57d:/# curl google.com 

------
<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>
```

如果有成功叫出HTML檔案，代表docker確實有保存安裝的插件



容器與虛擬機
------


### 什麼是虛擬機

理論上的說法是，在電腦上透過 `Hypervisor` 的軟體，將作業系統和硬體與應用程式分開，這樣就可以將自己劃分為數個獨立的 `虛擬機器`。

白話一點的說法是，可以想像成一個管家(Hypervisor)，幫你把一個房子分成好幾間套房，每一個套房都有自己的衛浴設備和供電設施，誰也不求誰，但還是佔掉整個房子的容積
，而且像是水龍頭的流水量，也因為多條水管牽線導致流水量不順暢。


虛擬機佔據的硬體比較多，啟動速度也比較慢，是因為每個虛擬機都可以獨立執行自己的作業系統和應用程式，同時還可以分配到從 `Hypervisor` 所管理的原始資源。
這些資源包括記憶體、RAM、儲存設備...等。


```md
> 虛擬機示意圖


-------------------  -------------------  -------------------
| Virtual Machine |  | Virtual Machine |  | Virtual Machine |
|-----------------|  |-----------------|  |-----------------|
|   App A         |  |   App B         |  |   App C         |
|-----------------|  |-----------------|  |-----------------|
|                 |  |                 |  |                 |
|   Guest         |  |   Guest         |  |   Guest         |
|   Operating     |  |   Operating     |  |   Operating     |
|   System        |  |   System        |  |   System        |
|                 |  |                 |  |                 |
|-----------------|  |-----------------|  |-----------------|

-------------------------------------------------------------
|                                                           |
|                  Hypervisor                               |
|                                                           |
|-----------------------------------------------------------|

|-----------------------------------------------------------|
|                                                           |
|                  Infrastructure                           |
|                                                           |
|-----------------------------------------------------------|
```


### 什麼是容器

容器其實就是一個抽象的應用層，把程式碼和相依套件打包在一起，多個容器可以在同一台機器上運作，並且和其他容器共享作業系統的核心(這和虛擬機完全不同)。   
虛擬機是每一個都有自己的作業系統，容器在Linux作業系統上作為獨立的執行程序相較於虛擬機，能夠佔用更少的空間，又能夠處理更多的應用程式。    


```md
> 容器示意圖


|----------| |----------| |----------| |----------| |----------|
|          | |          | |          | |          | |          |
|          | |          | |          | |          | |          |
|   App A  | |   App B  | |   App C  | |   App D  | |   App E  |
|          | |          | |          | |          | |          |
|----------| |----------| |----------| |----------| |----------|
  

----------------------------------------------------------------
|                                                              |
|                  Docker                                      |
|                                                              |
|---------------------------------------------------------------
|--------------------------------------------------------------|
|                                                              |
|                  Host Operating System                       |
|                                                              |
|---------------------------------------------------------------

|---------------------------------------------------------------
|                                                              |
|                  Infrastructure                              |
|                                                              |
|---------------------------------------------------------------
```





> ---    
> Docker 容器只是在 Linux 作業系統上的執行程序，並不是什麼迷你的虛擬機   
> 他能夠獲取的資源有限，在程序結束時，容器就會進入退出的狀態     
>    
> ---    
{: .block-tip}



### docker 容器只是在 Linux 作業系統上的執行程序

為了驗證 docker 只是一個在Linux 作業系統上的執行程序，我們先來啟動一個容器

```shell
$ docker container start ubuntu
```

再來使用top，來查看該容器的執行程序
```shell
# 這個指令的意思是，列出該容器的所有執行程序，可以看到列出的PID，也就是執行程序本身的ID
$ docker container top ubuntu

---------
UID            PID              PPID             C                STIME            TTY              TIME             CMD
root           2244             2217             0                10:25            ?                00:00:00         /bin/bash
```


那要怎麼驗證容器本身只是一個 Linux 作業系統上的執行程序呢？我們可以在 Linux 作業系統的終端機輸入 `ps aux` (列出系統所有執行程序資料)
這樣會看到容器內的PID和Linux作業系統的PID相同，這樣就可以驗證，其實 Docker 是跑在 Linux 的作業系統上，並非虛擬機的概念
如果今天是虛擬機，在當前的作業系統，是看不到執行程序的！

### 為什麼只提 Linux

會一直提 Linux 的原因，是因為 Mac 和 Windows 上的 Docker，是執行在迷你虛擬機上，所以當你在上述兩者作業系統中，列出所有執行程序，是沒辦法看到容器的執行程序

那要如何在 mac 上看到容器的執行序呢？我們需要先連上迷你的虛擬機，只要按照下方的指令，就可以看到虛擬機內的執行程序：
```shell
$ docker run -it --rm --privileged --pid=host justincormack/nsenter1
```

容器的IP和PORT
------




### 檢查容器的PORT

```shell
# 先在背景啟動一個nginx
$ docker container run --detach --publish 80:80 --name nginx nginx  

# 查看port
$ docker container port nginx

-------
80/tcp -> 0.0.0.0:80
```


### 0.0.0.0 和 127.0.0.1 在 Docker 中有哪裡不一樣

在 docker container port 回應中有看到 `0.0.0.0:80` ，這是因為容器本身沒有設定 IP 位置， Docker 預設為 `0.0.0.0`，和我們一般本機開發的 `127.0.0.1` 不太一樣，這代表什麼呢？

在 docker 世界， `127.0.0.1` 代表 `這個容器的本身`，而不是 `這台機器`，如果從一個容器向外連接到 `127.0.0.1` ，對於容器本身來說就像連到自己一樣。

如果今天有兩個容器要互相溝通，不小心把容器綁定成 `127.0.0.1` ，會沒辦法向外溝通，而 `0.0.0.0` 代表網路街口，他能接受來自其他容器的連接，以及外部的連接都能成功到達容器內。


### 容器的IP位置


我們前面都還沒談論過容器的IP位置，或許你會認為容器和主機都以相同的IP的位置執行，但其實不是，我們可以透過docker container inspect 指令來看到容器的 IP 位置：
```shell
$ docker container inspect --format '{{ .NetworkSettings.IPAddress }}' nginx

------
172.17.0.3
```

### 接著查看本機的IP位置

inet 10.8.8.147，這一段就是我們的本機IP位置

```shell
$ ifconfig en0

-------
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	options=6463<RXCSUM,TXCSUM,TSO4,TSO6,CHANNEL_IO,PARTIAL_CSUM,ZEROINVERT_CSUM>
	ether 1c:57:dc:45:4b:19 
	inet6 fe80::18ea:d978:4c81:d9ea%en0 prefixlen 64 secured scopeid 0xc 
	inet 10.8.8.147 netmask 0xffffff00 broadcast 10.8.8.255
	nd6 options=201<PERFORMNUD,DAD>
	media: autoselect
	status: active
```


Ps. 因此可以確定，本機和容器的IP位置是不同的



Docker 虛擬網路
------

### 電腦防火牆

防火牆一開始的意思，是古人使用木頭建造房屋時，為了避免火災蔓延，將堅固的石塊堆砌在房屋周圍作為屏障。     
而現代網路的意意思，是指隔離本機網路，與外界網路的一道防禦系統，藉由控制過濾限制訊息，來保護內部網路資料的安全。   

Ps. 防火牆預設阻止所有從網際網路中進來的流量，提到防火牆，就是希望透過著方式更理解Docker如何向網際網路打開大門，並讓外部請求進到容器內部。



### 打開防火牆

正常情況下，Docker預設會用一個叫做 `bridge` 的虛擬網路，我們可以透過以下指令來看：

```shell
$ docker network list

-------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
65abba938f22   external-service-network   bridge    local
86299be73d50   host                       host      local
bd3c20ec4d10   none                       null      local
```

這個虛擬網路幫我們橋接了本機的網路介面，讓我們可以透過簡單的 --publish 參數，快速啟動容器，並對應到防火牆該開啟哪個port。
若是沒有指定虛擬網路的情況下，Docker會預設使用這個 `bridge` 的虛擬網路，



這裡剛好可以提到，為什麼nginx的容器預設不會被分配到和本機相同的IP位置呢？
因為沒有指定網路的話，容器會以Docker的bridge虛擬網路優先，並連接上去，所以當然不同的網路環境會顯示不同的IP位置




我們可以透過以下指令，查看bridge這個虛擬網路的IP：


```shell
$ docker network inspect bridge

------
[
    {
        "Name": "bridge",
        "Id": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "Created": "2023-04-19T10:18:50.301027583Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        ......省略
    }
]
```


可以發現這一行："Gateway": "172.17.0.1"，還記得我們前面查看的nginx IP是多少嗎？
```shell
$ docker container inspect --format '{{ .NetworkSettings.IPAddress }}' nginx

------
172.17.0.3
```


就像前面說的一樣，沒有指定虛擬網路的情況下，Docker 預設使用bridge這個虛擬網路，而Docker則替我們在bridge網路內分配IP位置。
但是即使容器被分配到不同的IP位置，這又和網際網路的請求，能夠進入容器內部有什麼關係呢？



### NAT 網路位址轉換

Docker 透過 `NAT` 這項技術讓外部的請求進入 Docker，並順著虛擬網路找到容器。


NAT 這項技術被廣泛用在許多公司的內部網路，或是私人企業的內網中，主要原因是IPv4的位置稀少，很多企業或網路公司在只有少數的IP位置情況下，公司內部卻有太多電腦要連接網路，故採取共用IP的解決方法，就是讓一個IP位置給多台電腦使用。


使用者上網後，拿到一個IP位置，而IP分享器或無線基地台，則將一組專門給內部使用的私有IP分配給所有的內部電腦，內部每台電腦擁有一個 `192.168.0.X` 的IP位置，但無線基地台對外卻只有一個由網路公司賦予的IP位置。


通常，NAT將每一部電腦所用的IP，對應到共用IP，且NAT負責將進出封包的HEADER進行轉換，使得內部電腦可以輕鬆的用外部網路連線溝通。


用上述的概念，我們可以想像Docker本身就是負責分配IP的機器，而在Docker上運作的容器都是公司內部的電腦，被分配一個IP位置，但主要外面的入口還是要通過Docker來處理底層的網路技術。



### 操作 Docker 虛擬網路

#### list 指令

```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bd3c20ec4d10   none                       null      local
```

如果沒有特別建立虛擬網路的話，一開始應該只會看到這幾個虛擬網路。

(1) 第一個 bridge 是我們前面介紹 Docker 預設的虛擬網路，藉由 NAT 技術潛伏在主機的防火牆後方
(2) 第二個是 HOST 虛擬網路，這是一個特殊的服務，他跳過了 Docker 的虛擬網路，直接把容器連接到主機的網路介面上，這麼做有好處、也有壞處。壞處是安全性降低了，好處是可以提高網路的效能
(3) 最後一個是 none 虛擬網路，連到這個虛擬網路 = 沒有連到任何虛擬網路，有時候我們想要斷開某些曝光在網路的服務，可以暫時先將容器連接到 none 虛擬網路。


#### inspect 指令

`inspect` 是一個非常萬用的指令，不論搭配Docker哪先物件，都可以使用inspect指令來查看資訊

```shell
$ docker network inspect bridge   

------
[
    {
        "Name": "bridge",
        "Id": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "Created": "2023-04-19T10:18:50.301027583Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "42c5762b9b63674ff28ebb2021d2f3b2b0d341f14017943fa8f470ac3c046709": {
                "Name": "nginx",
                "EndpointID": "c431653f7de60d8e4ed823e5e243f4f8dcd3c21dae5d892029aaf8f77a6f5767",
                "MacAddress": "02:42:ac:11:00:03",
                "IPv4Address": "172.17.0.3/16",
                "IPv6Address": ""
            },
            "7a206a77f57dbff19428b8fa7b2f44639d138560607fbf30358bd5039a706084": {
                "Name": "ubuntu",
                "EndpointID": "d630a41211bca33964c600481f69610e65971a5b25e058383259ff325f2f18bf",
                "MacAddress": "02:42:ac:11:00:02",
                "IPv4Address": "172.17.0.2/16",
                "IPv6Address": ""
            }
        },
        ......省略
]
```

上面可以看到，Containers裡面有兩個容器連在bridge這個虛擬網路上。

### 建立自己的虛擬網路

app中的名字，可以取自己喜歡的
```shell
$ docker network create {app}

ex. docker network create newNetwork
```

在把list列出來，會發現剛剛新創的虛擬網路有在裡面
```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bfad8604bfd2   newNetwork                 bridge    local
bd3c20ec4d10   none                       null      local
```



### 添加原先的容器到虛擬網路中


如果我們想要把先前創建的容器，新增到剛剛創的虛擬網路，要怎麼做呢？使用 `--network 參數`

```shell
# 先清除舊有的所有容器
$ docker container rm --force $(docker container list --all --quiet)

# 新增一個容器
$ docker container run --detach --publish 80:80 --network {app} --name nginx nginx
------
4b4cd504eca96331f4c1740ff5fe906bd15031800817970c35a979fa8d2ca4d1
```

接著我們來確認一下剛剛那個指令，我們有沒有把容器連上剛剛創的虛擬網路
```shell
$ docker network inspect newNetwork

------
[
    {        
        ...省略
        "Containers": {
            "4b4cd504eca96331f4c1740ff5fe906bd15031800817970c35a979fa8d2ca4d1": {
                "Name": "nginx",
                "EndpointID": "f742988d816920ec25db21a6a6d5922b9e3b0a34a4e7ce61a1c732e948b13e50",
                "MacAddress": "02:42:ac:13:00:02",
                "IPv4Address": "172.19.0.2/16",
                "IPv6Address": ""
            }
        },
        ...省略

    }
]

```

確實有連上虛擬網路！但是在食物上，我們會需要替正在運作的容器，加進新的虛擬網路，這時候中斷容器服務，再重新使用 `--network` 的方式不太合理。


### 添加運作中的容器到新的虛擬網路


先新增一個postgres容器，並且讓他連接到預設bridge網路
Ps. 什麼都不設定，就是連到bridge
```shell
$ docker container run --detach --name pg --env POSTGRES_PASSWORD=password postgres
```

接著吧PG虛擬網路，跟剛剛新創的虛擬網路連接上去
Ps. 這個指令不會有反應，因為他沒有response
```shell
# newNetwork是虛擬網路的name，pg是容器的name
$ docker network connect newNetwork pg
```

那我們要怎麼驗證，這個容器有同時連接到兩個虛擬網路呢？一樣使用inspect就好了
```shell
$ docker container inspect pg

------
"Networks": {
    "bridge": {
        "IPAMConfig": null,
        "Links": null,
        "Aliases": null,
        "NetworkID": "9a64695ce968d37f5b622ceeb9516eb02a3ac821e17278e17d18151edf1810cd",
        "EndpointID": "c793fb4e1580a8f443a076502b81fad38852fd1b649bab122ac44e720a5395f8",
        "Gateway": "172.17.0.1",
        "IPAddress": "172.17.0.2",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "MacAddress": "02:42:ac:11:00:02",
        "DriverOpts": null
    ,
    "newNetwork": {
        "IPAMConfig": {},
        "Links": null,
        "Aliases": [
            "fe3ee07b5174"
        ],
        "NetworkID": "bfad8604bfd275abf2c53a0a04074bd9f3d1c6876b539bbef5cc73ef1f11a6a2",
        "EndpointID": "ce8f04560baa29bf8e983e440fda8389ab9a06591bae63e03a8d135f73b0c7e3",
        "Gateway": "172.19.0.1",
        "IPAddress": "172.19.0.3",
        "IPPrefixLen": 16,
        "IPv6Gateway": "",
        "GlobalIPv6Address": "",
        "GlobalIPv6PrefixLen": 0,
        "MacAddress": "02:42:ac:13:00:03",
        "DriverOpts": {}
```



這樣看此容器確實有連接到兩個虛擬網路！

### 中斷虛擬網路的連接

此指令可以中斷容器和虛擬網路的連接
Ps. 一樣不會有response
```shell
$ docker network disconnect newNetwork pg
```

### driver 是什麼

我們在列出虛擬網路的list時候，會發現有一個DRIVER的欄位
```shell
$ docker network list

------
NETWORK ID     NAME                       DRIVER    SCOPE
9a64695ce968   bridge                     bridge    local
86299be73d50   host                       host      local
bfad8604bfd2   newNetwork                 bridge    local
bd3c20ec4d10   none                       null      local
```

看到上面的資料應該會覺得有一個地方很神奇，就是 `newNetwork` 也就是我們新創的虛擬網路，他的 `DRIVER` 也是用 `bridge`。
原因就是如果今天沒有指定driver的話，docker預設的driver就是bridge。

使用bridge當作driver的虛擬網路，通常適用在單主機的容器們需要互相溝通的情況。為什麼強調是單主機呢？因為後面會提到另外一個driver，就是 `overlay`，這種虛擬網路可以跨平台溝通。


Docker 的 DNS
------

在 docker 的世界，我們可以忘掉IP位置這件事情，因為前面提到過，容器的IP會由Docker做分配，每次容器啟動的時機不同，都會導致IP位置不一樣，所以想要透過IP位置來做容器間的相互溝通，是不太實際的。

因此DNS就是Docker的解決方案，當我們對一個容器命名後(--name)，在Docker虛擬網路中，我們為他的命名就是這跟服物的DNS，我們可以透過他的名字，訪問到容器。


### 用 IP 位置來溝通





### 用 DNS 來溝通























































