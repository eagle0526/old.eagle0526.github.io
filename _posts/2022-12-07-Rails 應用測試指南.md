---
title: Rails 應用測試指南
author: YeeChen
date: 2022-12-07
category: Rails-minitest
layout: post
---
**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON https://guides.rubyonrails.org.**

Rails 應用程式測試
==========================

此頁教學包含了Rails中，用於測試應用程式的機制

等閱讀完粗篇教學後，你將會學到：

* Rails 的測試術語
* 如何為你的系統寫單元測試、功能測試、整合測試和系統測試
* 其他受歡迎的測試方法、插件

--------------------------------------------------------------------------------

為何什麼要為你的Rails應用程式寫測試呢？
--------------------------------------------
Rails 讓編寫測試變得非常容易。當你創造models、controllers的時候，就會順便建立一個框架測試代碼。  

藉由運行測試，你可以確保你的程式碼，即使在主要程式碼重構之後，也可以保證功能一樣的正常運行。   

Rails 還可以模擬瀏覽器的requests，也因此讓您無需通過瀏覽器，就可以測試應用程式的response。   
   
測試介紹
-----------------------

在一開始，支援測試就已經被編寫入Rails的結構之中，不是因為「哇！因為測試是新的酷東西，所以我們把測試加進去」

### Rails Sets up for Testing from the Word Go
### Rails 開始進行測試
當你用`rails new` "專案名稱" 的時候，Rails會馬上幫你產生一個 `test` 的資料夾，如果你列出目錄的話，你將會看到：   

```bash
$ ls -F test
application_system_test_case.rb  controllers/                     helpers/                         mailers/                         system/
channels/                        fixtures/                        integration/                     models/                          test_helper.rb
```

`system` 系統測試資料夾代表系統測試，他被使用於對應用程式進行完整的瀏覽器測試。系統測試可以讓你以使用者體驗的角度，去測試你的應用程式，並幫助你測試 JavaScript。系統測試繼承於 Capybara，並在你應用程式的瀏覽器測試中執行

Fixtures 是一種測管理測試數據的方式，他們會在 `fixtures` 這個資料夾裡面。  

`jobs` 資料夾將會在第一個關聯測試被產生的時候，順便新建一個出來  

`test_helper.rb` 檔案中包含預設的測試設定。  

`application_system_test_case.rb` 檔案中包含了系統測試的預設設定。   


### 測試環境

每個Rails應用程式，預設下都有三個環境：開發、測試、生產環境。  

每個環境設置都可以被修改，以這個為範例，我們可以藉由改變 `config/environments/test.rb` 的選項，來修改測試環境。  

備註：你的測試運行在 `RAILS_ENV=test` 下面。   


### Rails 運行 Minitest

如果你記得，我們在 [Getting Started with Rails](getting_started.html) 這個教學中，使用 `bin/rails generate model` 這個指令來創造我們第一個Model，而且還順便在 `test` 資料夾中創建test stubs。  

```bash
$ bin/rails generate model article title:string body:text
...
create  app/models/article.rb
create  test/models/article_test.rb
create  test/fixtures/articles.yml
...
```

在 `test/models/article_test.rb` 中，預設的 test stub 看起來像這樣：   


```ruby
require "test_helper"

class ArticleTest < ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
```
逐行檢查檔案將會幫助你了解 Rails 測試的程式碼、術語  

```ruby
require "test_helper"
```
`test_helper.rb` 此檔案中包含加載了運行我們測試的預設設定。藉由引用此檔案，我們將會把它包含在我們所有寫的測試之中，因此寫在此文件的所有方法，都可以用在我們所有測試裡面。


```ruby
class ArticleTest < ActiveSupport::TestCase
```

因為 `ArticleTest` 繼承自 `ActiveSupport::TestCase`，所以此類別也有定義一個 _test case_ 方法，因此 `ArticleTest` 具有 `ActiveSupport::TestCase` 中所有可以用的方法。在本教學後面，我們將會看到他為我們提供的一些方法。

The `ArticleTest` class defines a _test case_ because it inherits from `ActiveSupport::TestCase`. `ArticleTest` thus has all the methods available from `ActiveSupport::TestCase`. Later in this guide, we'll see some of the methods it gives us.


任何繼承自 `Minitest::Test` (他是 `ActiveSupport::TestCase` 的 superclass) 而且名稱開頭為 `test_` 的方法，都簡稱為測試。
因此，當方法被定義為 `test_password` 和 `test_valid_password` 時，兩者都是合法的測試名稱，並且當測試用例運行時，會自動運行。

Any method defined within a class inherited from `Minitest::Test`
(which is the superclass of `ActiveSupport::TestCase`) that begins with `test_` is simply called a test. So, methods defined as `test_password` and `test_valid_password` are legal test names and are run automatically when the test case is run.

Rails 還有一個 `test` 方法，他可以接受測試一個名稱、區塊。他會生成一個名稱前綴為 `test_` 的 `Minitest::Unit` 測試。所以你不必擔心命名方法，你可以這樣寫：

```ruby
test "the truth" do
  assert true
end
```

上面那樣寫跟下面這樣差不多
Which is approximately the same as writing this:

```ruby
def test_the_truth
  assert true
end
```

雖然您仍然可以使用常規方法定義名稱，但使用 `test` 取名方式可以有更好的可讀性。
Although you can still use regular method definitions, using the `test` macro allows for a more readable test name.

標註：方法名稱是用下劃線取代空格產生的。名稱結果不需要是Ruby有效的標示符，可以包含標點符號...等等，這是因為技術上來說，Ruby任何字串都可以是方法名稱。雖然可能需要適當的使用 `define_method` 和 `send` 兩種函式，但形式上對名稱幾乎是沒有限制的。

NOTE: The method name is generated by replacing spaces with underscores. The result does not need to be a valid Ruby identifier though — the name may contain punctuation characters, etc. That's because in Ruby technically any string may be a method name. This may require use of `define_method` and `send` calls to function properly, but formally there's little restriction on the name.

接下來，讓我們來看第一個斷言：
Next, let's look at our first assertion:

```ruby
assert true
```

斷言是一行代碼，他是用來推測物件、表達式的預期結果。例如， 斷言可以檢查：
An assertion is a line of code that evaluates an object (or expression) for expected results. For example, an assertion can check:

* 前面的值等於後面的值嗎？
* 這個物件是nil嗎？
* 這行程式碼會丟出例外處理嗎？
* 使用者的密碼有超過5個字數嗎？

每個測試都可以包含一個斷言或多個斷言，對允許斷言的數量沒有限制，只有當所有的斷言成功時，測試才會通過。
Every test may contain one or more assertions, with no restriction as to how many assertions are allowed. Only when all the assertions are successful will the test pass.

#### Your First Failing Test
#### 第一個失敗的測試

如果想要看失敗的測試報告，你可把失敗的測試加進 `article_test.rb` 這個測試用例中。
To see how a test failure is reported, you can add a failing test to the `article_test.rb` test case.

```ruby
test "should not save article without title" do
  article = Article.new
  assert_not article.save
end
```

讓我們來對這個新增的行數進行測試(..rb:6 的意思是，我要對該檔案這一行進行測試)
Let us run this newly added test (where `6` is the number of line where the test is defined).

```bash
$ bin/rails test test/models/article_test.rb:6
Run options: --seed 44656

# Running:

F

Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Expected true to be nil or false


rails test test/models/article_test.rb:6



Finished in 0.023918s, 41.8090 runs/s, 41.8090 assertions/s.

1 runs, 1 assertions, 1 failures, 0 errors, 0 skips
```

在輸出結果中， `F` 代表失敗。你可以先看到相對應失敗測試的名稱，接下來幾行包含斷言的實際值、預期值得訊息。
預設的斷言訊息的訊息，足以幫助我們找到錯誤，為了讓斷言的錯誤訊息更具可讀性，每個斷言提供一些參數選項做修改，如下：
In the output, `F` denotes a failure. You can see the corresponding trace shown under `Failure` along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:

```ruby
test "should not save article without title" do
  article = Article.new
  assert_not article.save, "Saved the article without a title"
end
```

運行此測試會顯示出更易讀的斷言訊息：
Running this test shows the friendlier assertion message:

```
Failure:
ArticleTest#test_should_not_save_article_without_title [/path/to/blog/test/models/article_test.rb:6]:
Saved the article without a title
```

現在，為了讓這個測試通過，我們可以幫此model的 _title_ 加上驗證
Now to get this test to pass we can add a model level validation for the _title_ field.

```ruby
class Article < ApplicationRecord
  validates :title, presence: true
end
```

現在這個測試應該可以通過，讓我們再跑一次測試：
Now the test should pass. Let us verify by running the test again:

```bash
$ bin/rails test test/models/article_test.rb:6
Run options: --seed 31252

# Running:

.

Finished in 0.027476s, 36.3952 runs/s, 36.3952 assertions/s.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
```

現在，如果你有注意到，我們第一個寫的測試，他沒有達到預期的功能性，然後我們加了一些程式碼來添加功能，最後確保測試可以通過。
這種開發流程就被稱作為[_Test-Driven Development_ (TDD)](http://c2.com/cgi/wiki?TestDrivenDevelopment)。

Now, if you noticed, we first wrote a test which fails for a desired
functionality, then we wrote some code which adds the functionality and finally
we ensured that our test passes. This approach to software development is
referred to as
[_Test-Driven Development_ (TDD)](http://c2.com/cgi/wiki?TestDrivenDevelopment).

#### What an Error Looks Like
#### 錯誤看起來是什麼樣子

這裡有一個錯誤的測試，我們來看一下錯誤是如何報告的。
To see how an error gets reported, here's a test containing an error:

```ruby
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  some_undefined_variable
  assert true
end
```
先直接此測試後，現在你可以在終端機看到更多的輸出內容
Now you can see even more output in the console from running the tests:

```bash
$ bin/rails test test/models/article_test.rb
Run options: --seed 1808

# Running:

.E

Error:
ArticleTest#test_should_report_error:
NameError: undefined local variable or method 'some_undefined_variable' for #<ArticleTest:0x007fee3aa71798>
    test/models/article_test.rb:11:in 'block in <class:ArticleTest>'


rails test test/models/article_test.rb:9



Finished in 0.040609s, 49.2500 runs/s, 24.6250 assertions/s.

2 runs, 1 assertions, 0 failures, 1 errors, 0 skips
```
注意到 `E` 這個輸出，他代表這個測試是錯的
Notice the 'E' in the output. It denotes a test with error.

備註：只要有任何錯誤，或者是斷言失敗發生，測試的執行就會停止，並且測試套件會繼續執行下一個方法。所有的測試方法是隨機去執行的。[`config.active_support.test_order`](https://guides.rubyonrails.org/configuring.html#config-active-support-test-order) 這個選項可以設定測試順序。

NOTE: The execution of each test method stops as soon as any error or an
assertion failure is encountered, and the test suite continues with the next
method. All test methods are executed in random order. The
[`config.active_support.test_order`](https://guides.rubyonrails.org/configuring.html#config-active-support-test-order) option can be used to configure test order.

當測試失敗，你會看到相對應的回溯，預設下，Rails 會過濾出回溯和印出與你應用程式相關的行，這可以幫助你專注於你的程式碼。不過如果你想要看完整的回溯的話，可以在指令加上 `-b` (或是 --`backtrace`)來啟用此行為。

When a test fails you are presented with the corresponding backtrace. By default
Rails filters that backtrace and will only print lines relevant to your
application. This eliminates the framework noise and helps to focus on your
code. However there are situations when you want to see the full
backtrace. Set the `-b` (or `--backtrace`) argument to enable this behavior:

```bash
$ bin/rails test -b test/models/article_test.rb
```

如果你想要讓下面這個測試通過，可以用 `assert_raises` 來修改它，像這樣：
If we want this test to pass we can modify it to use `assert_raises` like so:

```ruby
test "should report error" do
  # some_undefined_variable is not defined elsewhere in the test case
  assert_raises(NameError) do
    some_undefined_variable
  end
end
```

這個測試應該可以通過
This test should now pass.

[`config.active_support.test_order`]: configuring.html#config-active-support-test-order

### Available Assertions
### 可以用的斷言

到目前為止，你已經看到許多可以用的斷言了，斷言是測試用的工蜂，他們是實際執行檢查，確保事情按照計劃執行的人。   
By now you've caught a glimpse of some of the assertions that are available. Assertions are the worker bees of testing. They are the ones that actually perform the checks to ensure that things are going as planned.

這邊是你可以用的斷言摘錄 [`Minitest`](https://github.com/seattlerb/minitest)，他是Rails預設的測試資料庫。`Msg` 是可新增的字串訊息，可以使用它讓你的測試失敗訊息更易讀。
Here's an extract of the assertions you can use with
[`Minitest`](https://github.com/seattlerb/minitest), the default testing library
used by Rails. The `[msg]` parameter is an optional string message you can
specify to make your test failure messages clearer.

| Assertion                                                        | Purpose |
| ---------------------------------------------------------------- | ------- |
| `assert( test, [msg] )`                                          | Ensures that `test` is true.|
| `assert_not( test, [msg] )`                                      | Ensures that `test` is false.|
| `assert_equal( expected, actual, [msg] )`                        | Ensures that `expected == actual` is true.|
| `assert_not_equal( expected, actual, [msg] )`                    | Ensures that `expected != actual` is true.|
| `assert_same( expected, actual, [msg] )`                         | Ensures that `expected.equal?(actual)` is true.|
| `assert_not_same( expected, actual, [msg] )`                     | Ensures that `expected.equal?(actual)` is false.|
| `assert_nil( obj, [msg] )`                                       | Ensures that `obj.nil?` is true.|
| `assert_not_nil( obj, [msg] )`                                   | Ensures that `obj.nil?` is false.|
| `assert_empty( obj, [msg] )`                                     | Ensures that `obj` is `empty?`.|
| `assert_not_empty( obj, [msg] )`                                 | Ensures that `obj` is not `empty?`.|
| `assert_match( regexp, string, [msg] )`                          | Ensures that a string matches the regular expression.|
| `assert_no_match( regexp, string, [msg] )`                       | Ensures that a string doesn't match the regular expression.|
| `assert_includes( collection, obj, [msg] )`                      | Ensures that `obj` is in `collection`.|
| `assert_not_includes( collection, obj, [msg] )`                  | Ensures that `obj` is not in `collection`.|
| `assert_in_delta( expected, actual, [delta], [msg] )`            | Ensures that the numbers `expected` and `actual` are within `delta` of each other.|
| `assert_not_in_delta( expected, actual, [delta], [msg] )`        | Ensures that the numbers `expected` and `actual` are not within `delta` of each other.|
| `assert_in_epsilon ( expected, actual, [epsilon], [msg] )`       | Ensures that the numbers `expected` and `actual` have a relative error less than `epsilon`.|
| `assert_not_in_epsilon ( expected, actual, [epsilon], [msg] )`   | Ensures that the numbers `expected` and `actual` have a relative error not less than `epsilon`.|
| `assert_throws( symbol, [msg] ) { block }`                       | Ensures that the given block throws the symbol.|
| `assert_raises( exception1, exception2, ... ) { block }`         | Ensures that the given block raises one of the given exceptions.|
| `assert_instance_of( class, obj, [msg] )`                        | Ensures that `obj` is an instance of `class`.|
| `assert_not_instance_of( class, obj, [msg] )`                    | Ensures that `obj` is not an instance of `class`.|
| `assert_kind_of( class, obj, [msg] )`                            | Ensures that `obj` is an instance of `class` or is descending from it.|
| `assert_not_kind_of( class, obj, [msg] )`                        | Ensures that `obj` is not an instance of `class` and is not descending from it.|
| `assert_respond_to( obj, symbol, [msg] )`                        | Ensures that `obj` responds to `symbol`.|
| `assert_not_respond_to( obj, symbol, [msg] )`                    | Ensures that `obj` does not respond to `symbol`.|
| `assert_operator( obj1, operator, [obj2], [msg] )`               | Ensures that `obj1.operator(obj2)` is true.|
| `assert_not_operator( obj1, operator, [obj2], [msg] )`           | Ensures that `obj1.operator(obj2)` is false.|
| `assert_predicate ( obj, predicate, [msg] )`                     | Ensures that `obj.predicate` is true, e.g. `assert_predicate str, :empty?`|
| `assert_not_predicate ( obj, predicate, [msg] )`                 | Ensures that `obj.predicate` is false, e.g. `assert_not_predicate str, :empty?`|
| `flunk( [msg] )`                                                 | Ensures failure. This is useful to explicitly mark a test that isn't finished yet.|

以上是minitest支援的斷言子集，如果想要看更詳細的列表，可以看這個
[Minitest API documentation](http://docs.seattlerb.org/minitest/), specifically
[`Minitest::Assertions`](http://docs.seattlerb.org/minitest/Minitest/Assertions.html).

The above are a subset of assertions that minitest supports. For an exhaustive &
more up-to-date list, please check
[Minitest API documentation](http://docs.seattlerb.org/minitest/), specifically
[`Minitest::Assertions`](http://docs.seattlerb.org/minitest/Minitest/Assertions.html).


因為測試框架模塊化的特性，你可以自己創造斷言，事實上，這是Rails所做的，他做了一些斷言讓你寫測試更輕鬆。  
Because of the modular nature of the testing framework, it is possible to create your own assertions. In fact, that's exactly what Rails does. It includes some specialized assertions to make your life easier.

備註：創建自己的斷言是進階主題，我們在這邊不會教到。   
NOTE: Creating your own assertions is an advanced topic that we won't cover in this tutorial.

### Rails Specific Assertions
### Rails 特定的斷言

Rails將自己一些自定義的斷言加進 `minitest` 這個框架中：
Rails adds some custom assertions of its own to the `minitest` framework:

| Assertion                                                                         | Purpose |
| --------------------------------------------------------------------------------- | ------- |
| [`assert_difference(expressions, difference = 1, message = nil) {...}`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_difference) | Test numeric difference between the return value of an expression as a result of what is evaluated in the yielded block.|
| [`assert_no_difference(expressions, message = nil, &block)`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_difference) | Asserts that the numeric result of evaluating an expression is not changed before and after invoking the passed in block.|
| [`assert_changes(expressions, message = nil, from:, to:, &block)`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_changes) | Test that the result of evaluating an expression is changed after invoking the passed in block.|
| [`assert_no_changes(expressions, message = nil, &block)`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_no_changes) | Test the result of evaluating an expression is not changed after invoking the passed in block.|
| [`assert_nothing_raised { block }`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/Assertions.html#method-i-assert_nothing_raised) | Ensures that the given block doesn't raise any exceptions.|
| [`assert_recognizes(expected_options, path, extras={}, message=nil)`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_recognizes) | Asserts that the routing of the given path was handled correctly and that the parsed options (given in the expected_options hash) match path. Basically, it asserts that Rails recognizes the route given by expected_options.|
| [`assert_generates(expected_path, options, defaults={}, extras = {}, message=nil)`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html#method-i-assert_generates) | Asserts that the provided options can be used to generate the provided path. This is the inverse of assert_recognizes. The extras parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The message parameter allows you to specify a custom error message for assertion failures.|
| [`assert_response(type, message = nil)`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_response) | Asserts that the response comes with a specific status code. You can specify `:success` to indicate 200-299, `:redirect` to indicate 300-399, `:missing` to indicate 404, or `:error` to match the 500-599 range. You can also pass an explicit status number or its symbolic equivalent. For more information, see [full list of status codes](https://rubydoc.info/gems/rack/Rack/Utils#HTTP_STATUS_CODES-constant) and how their [mapping](https://rubydoc.info/gems/rack/Rack/Utils#SYMBOL_TO_STATUS_CODE-constant) works.|
| [`assert_redirected_to(options = {}, message=nil)`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/ResponseAssertions.html#method-i-assert_redirected_to) | Asserts that the response is a redirect to a URL matching the given options. You can also pass named routes such as `assert_redirected_to root_path` and Active Record objects such as `assert_redirected_to @article`.|

你將會在下一章節看到一些斷言的用法。
You'll see the usage of some of these assertions in the next chapter.


### A Brief Note About Test Cases
### 關於測試用例的簡短說明

我們在自己的測試案例中，可以使用繼承自 `Minitest::Assertions` 類別的所有基本斷言，像是 `assert_equal`。事實上，Rails以下類別都是繼承自 `Minitest::Assertions`：
All the basic assertions such as `assert_equal` defined in `Minitest::Assertions` are also available in the classes we use in our own test cases. In fact, Rails provides the following classes for you to inherit from:

* [`ActiveSupport::TestCase`](https://api.rubyonrails.org/classes/ActiveSupport/TestCase.html)
* [`ActionMailer::TestCase`](https://api.rubyonrails.org/classes/ActionMailer/TestCase.html)
* [`ActionView::TestCase`](https://api.rubyonrails.org/classes/ActionView/TestCase.html)
* [`ActiveJob::TestCase`](https://api.rubyonrails.org/classes/ActiveJob/TestCase.html)
* [`ActionDispatch::IntegrationTest`](https://api.rubyonrails.org/classes/ActionDispatch/IntegrationTest.html)
* [`ActionDispatch::SystemTestCase`](https://api.rubyonrails.org/classes/ActionDispatch/SystemTestCase.html)
* [`Rails::Generators::TestCase`](https://api.rubyonrails.org/classes/Rails/Generators/TestCase.html)

這些類別都包含 `Minitest::Assertions` ，允許我們在測試中去使用所有的基本斷言。
Each of these classes include `Minitest::Assertions`, allowing us to use all of the basic assertions in our tests.

備註：更多關於 `Minitest` 的資訊，可以點擊[its documentation](http://docs.seattlerb.org/minitest)。
NOTE: For more information on `Minitest`, refer to [its documentation](http://docs.seattlerb.org/minitest).

### The Rails Test Runner
### Rails 執行測試

我們可以用 `bin/rails test` 指令來執行測試。
We can run all of our tests at once by using the `bin/rails test` command.

或者我們可以透過將檔案名稱包含在 `bin/rails test` 指令裡面，藉此來執行單個檔案的測試用例
Or we can run a single test file by passing the `bin/rails test` command the filename containing the test cases.

```bash
$ bin/rails test test/models/article_test.rb
Run options: --seed 1559

# Running:

..

Finished in 0.027034s, 73.9810 runs/s, 110.9715 assertions/s.

2 runs, 3 assertions, 0 failures, 0 errors, 0 skips
```

這會在這個測試用例中，執行所有的測試方法。
This will run all test methods from the test case.

你可以藉由輸入 `-n` 或是 `--name` 加上方法名稱，來執行該測試用例中的特定測試方法
You can also run a particular test method from the test case by providing the
`-n` or `--name` flag and the test's method name.

```bash
$ bin/rails test test/models/article_test.rb -n test_the_truth
Run options: -n test_the_truth --seed 43583

# Running:

.

Finished tests in 0.009064s, 110.3266 tests/s, 110.3266 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
```

你也可以輸入程式碼的行數，來執行特定行數的測試。
You can also run a test at a specific line by providing the line number.

```bash
$ bin/rails test test/models/article_test.rb:6 # run specific test and line
```

你也可以輸入資料夾的路徑，來執行整個資料夾中的測試。
You can also run an entire directory of tests by providing the path to the directory.

```bash
$ bin/rails test test/controllers # run all tests from specific directory
```

測試還提供了很多其他的功能，像是快速失敗、當這次執行結束時，延緩測試輸出...等等。檢查測試執行器的文件：
The test runner also provides a lot of other features like failing fast, deferring test output
at the end of the test run and so on. Check the documentation of the test runner as follows:

```bash
$ bin/rails test -h
Usage: rails test [options] [files or directories]

You can run a single test by appending a line number to a filename:

    bin/rails test test/models/user_test.rb:27

You can run multiple files and directories at the same time:

    bin/rails test test/controllers test/integration/login_test.rb

By default test failures and errors are reported inline during a run.

minitest options:
    -h, --help                       Display this help.
        --no-plugins                 Bypass minitest plugin auto-loading (or set $MT_NO_PLUGINS).
    -s, --seed SEED                  Sets random seed. Also via env. Eg: SEED=n rake
    -v, --verbose                    Verbose. Show progress processing files.
    -n, --name PATTERN               Filter run on /regexp/ or string.
        --exclude PATTERN            Exclude /regexp/ or string from run.

Known extensions: rails, pride
    -w, --warnings                   Run with Ruby warnings enabled
    -e, --environment ENV            Run tests in the ENV environment
    -b, --backtrace                  Show the complete backtrace
    -d, --defer-output               Output test failures and errors after the test run
    -f, --fail-fast                  Abort test run on first failure or error
    -c, --[no-]color                 Enable color in the output
    -p, --pride                      Pride. Show your testing pride!
```

### Running tests in Continuous Integration (CI)
### 在持續整合中執行測試 (CI)

在持續整合的環境中執行測試，只需要輸入一行指令：
To run all tests in a CI environment, there's just one command you need:

```
bin/rails test
```

如果你使用 [System Tests](#system-testing)， `bin/rails test` 將不會執行系統測試，因為這樣會讓他變很慢，如果想要讓他們正常執行，只要輸入 `bin/rails test:system` 或是改變第一步驟的指令 `bin/rails test:all`，這樣就可以讓你在執行測試的時候，把系統測試包含在裡面。
If you are using [System Tests](#system-testing), `bin/rails test` will not run them, since
they can be slow. To also run them, add an another CI step that runs `bin/rails test:system`,
or change your first step to `bin/rails test:all`, which runs all tests including system tests.

平行測試
----------------

平行測試允許你平行你的測試套件，雖然分叉進程是預設方法，但是單線進程也是支持的，平行測試可以讓你減少測試執行的時間。
Parallel testing allows you to parallelize your test suite. While forking processes is the
default method, threading is supported as well. Running tests in parallel reduces the time it
takes your entire test suite to run.

### Parallel Testing with Processes
### 執行平行測試

預設的平行方法是使用Ruby的DRb系統來運作的。這些進程根據根據有多少數量的工人來進行分叉。預設的數量是根據你電腦所擁有的核心數，不過可以透過平行方法並給予參數來改變數量。

The default parallelization method is to fork processes using Ruby's DRb system. The processes
are forked based on the number of workers provided. The default number is the actual core count
on the machine you are on, but can be changed by the number passed to the parallelize method.

在 `test_helper.rb` 此檔案裡面，可以找到平行方法：
To enable parallelization add the following to your `test_helper.rb`:

```ruby
class ActiveSupport::TestCase
  parallelize(workers: 2)
end
```

有多少個工人數量，就代表進程會被分叉幾次，你可能希望用不同於持續整合(CI)的方式，平行本地測試插件，因此有一個環境變數提供你去更改測試的工人數量：
The number of workers passed is the number of times the process will be forked. You may want to
parallelize your local test suite differently from your CI, so an environment variable is provided
to be able to easily change the number of workers a test run should use:

```bash
$ PARALLEL_WORKERS=15 bin/rails test
```

當平行測試時，Active Record會自動處理創建數據庫，並加載schema到每個數據庫的進程之中。數據庫將會以工人相對應的編號作為後綴。例如，如果你在這個測試有兩個工人，這個測試會分別創造 `test-database-0`和 `test-database-1`。
When parallelizing tests, Active Record automatically handles creating a database and loading the schema into the database for each
process. The databases will be suffixed with the number corresponding to the worker. For example, if you
have 2 workers the tests will create `test-database-0` and `test-database-1` respectively.


如果工人的數量是1個或是低於進程數量，就不會分叉進行，測試也不會進行平行測試，資料庫也會使用原本的 `test-database`。
If the number of workers passed is 1 or fewer the processes will not be forked and the tests will not
be parallelized and the tests will use the original `test-database` database.


提供兩個 hooks，一個是在進程分叉時運行，一個是在分叉進程關閉前運行，如果你的應用程式使用多個資料庫，或者執行其他取決於工作人員數量的任務，這會非常的有用。
Two hooks are provided, one runs when the process is forked, and one runs before the forked process is closed.
These can be useful if your app uses multiple databases or performs other tasks that depend on the number of
workers.

進程被分叉後，`parallelize_setup` 這個方法會被調用，進程被關閉前，`parallelize_teardown` 這個方法會被調用。
The `parallelize_setup` method is called right after the processes are forked. The `parallelize_teardown` method
is called right before the processes are closed.

```ruby
class ActiveSupport::TestCase
  parallelize_setup do |worker|
    # setup databases
  end

  parallelize_teardown do |worker|
    # cleanup databases
  end

  parallelize(workers: :number_of_processors)
end
```

使執行緒平行測試時，不可以用這些方法。
These methods are not needed or available when using parallel testing with threads.

### Parallel Testing with Threads
### 使用執行緒進行平行測試


如果你更喜歡使用執行緒或者是JRuby，這邊有提供另外用執行緒平行選項使用，執行緒平行器有得到Minitest的 `Parallel::Executor` 支援。
If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded
parallelizer is backed by Minitest's `Parallel::Executor`.

更改平行化方法，讓你可以在分叉上使用執行緒，請把下面的程式碼放進 `test_helper.rb`
To change the parallelization method to use threads over forks put the following in your `test_helper.rb`

```ruby
class ActiveSupport::TestCase
  parallelize(workers: :number_of_processors, with: :threads)
end
```

從JRuby或是TruffleRuby生成的Rails應用程式，將自動包含 `with: :threads` 選項。
Rails applications generated from JRuby or TruffleRuby will automatically include the `with: :threads` option.

傳遞給 `parallelize` 的數量，將決定此測試會使用多少執行緒數量，你可能會希望以不同於持續整合(CI)的方式，平行化本地測試插件，因此有提供一個環境變數，方便去更改執行測試應該要使用的工人數量：
The number of workers passed to `parallelize` determines the number of threads the tests will use. You may
want to parallelize your local test suite differently from your CI, so an environment variable is provided
to be able to easily change the number of workers a test run should use:

```bash
$ PARALLEL_WORKERS=15 bin/rails test
```

### Testing Parallel Transactions
### 測試平行交易(Transactions)

Rails會自動將任何的測試用例，包裝在測試完成後回滾(rollback)的資料庫交易(transaction)中，這會讓測試用例彼此獨立，並且對資料庫的更改只有在單個測試中可以看到。
Rails automatically wraps any test case in a database transaction that is rolled
back after the test completes.  This makes test cases independent of each other
and changes to the database are only visible within a single test.

當你想要測試在執行緒中執行平行交易(transactions)的程式碼時，交易(transactions)可以互相阻擋，因為他們已經鑲嵌在測試交易(transactions)下面。
When you want to test code that runs parallel transactions in threads,
transactions can block each other because they are already nested under the test
transaction.

你可以透過設定 `self.use_transactional_tests = false` ，來關閉測試用例類別中的交易(transactions)。
You can disable transactions in a test case class by setting
`self.use_transactional_tests = false`:

```ruby
class WorkerTest < ActiveSupport::TestCase
  self.use_transactional_tests = false

  test "parallel transactions" do
    # start some threads that create transactions
  end
end
```

標註：對於禁止使用的交易(transactional)測試，你必須去清除任何測試新增的任何數據，因為測試完成後，更改不會自動回滾(rollback)
NOTE: With disabled transactional tests, you have to clean up any data tests
create as changes are not automatically rolled back after the test completes.

### Threshold to parallelize tests
### 平行化測試的閾值

平行測試會增加數據庫設定和夾具(fixture)加載方面的開銷。因此Rails不會平行執行少於50個測試的執行。
Running tests in parallel adds an overhead in terms of database setup and
fixture loading. Because of this, Rails won't parallelize executions that involve
fewer than 50 tests.

你可以在 `test.rb` 設定你的閾值：
You can configure this threshold in your `test.rb`:

```ruby
config.active_support.test_parallelization_threshold = 100
```

你也可以在測試用例的地方設定閾值：
And also when setting up parallelization at the test case level:

```ruby
class ActiveSupport::TestCase
  parallelize threshold: 100
end
```

測試資料庫
-----------------

每個Rails的應用程式，幾乎都會與資料庫進行大量的交互運作，因此你的測試也會需要與資料庫進行交互運作，為了要寫更高效率的測試，你需要了解如何設定資料庫、使用樣本數據填充他。
Just about every Rails application interacts heavily with a database and, as a result, your tests will need a database to interact with as well. To write efficient tests, you'll need to understand how to set up this database and populate it with sample data.

預設下，每個Rails的應用程式有三個環境：開發、測試、生產(production)，每個數據庫都在 `config/database.yml` 中設定。
By default, every Rails application has three environments: development, test, and production. The database for each one of them is configured in `config/database.yml`.

專用測試資料庫允許你單獨設定測試數據並和他交互使用，這樣可以讓你很有信心的處理測試資料，不用擔心會影響到開發、生產(production)的資料庫。
A dedicated test database allows you to set up and interact with test data in isolation. This way your tests can mangle test data with confidence, without worrying about the data in the development or production databases.

### Maintaining the Test Database Schema
### 維護測試資料庫的架構(Schema)


為了執行測試，你的測試資料庫需要有目前的架構，`test helper` 會確認你目前是否有任何的 `pending migrations`，他會嘗試加載你的 `db/schema.rb`、`db/structure.sql` 匯入測試資料庫。如果還有migrations還有 `pending` 狀態，會引發錯誤，通常這代表 `schema` 尚未完全的 `migrate`，執行 `bin/rails db:migrate` 會保持 `schema` 保持最新狀態。

In order to run your tests, your test database will need to have the current
structure. The test helper checks whether your test database has any pending
migrations. It will try to load your `db/schema.rb` or `db/structure.sql`
into the test database. If migrations are still pending, an error will be
raised. Usually this indicates that your schema is not fully migrated. Running
the migrations against the development database (`bin/rails db:migrate`) will
bring the schema up to date.

備註： 如果對現有的 `migrations` 進行修改，測試資料庫就需要重新建立，可以執行 `bin/rails db:test:prepare` 來做到這件事。
NOTE: If there were modifications to existing migrations, the test database needs to
be rebuilt. This can be done by executing `bin/rails db:test:prepare`.

### The Low-Down on Fixtures
### 夾具(Fixtures)的內幕(Low-Down)

對於良好的測試，你需要考慮測試數據的設定，在Rails，你可以通過定義、客製夾具(fixtures)來處理這個需求。你可以在 [Fixtures API documentation](https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html) 找到全面的文件。
For good tests, you'll need to give some thought to setting up test data.
In Rails, you can handle this by defining and customizing fixtures.
You can find comprehensive documentation in the [Fixtures API documentation](https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html).

#### What are Fixtures?
#### 什麼是 夾具(Fixtures)?

_Fixtures_ 是樣本數據中特別的單字，夾具(Fixtures)允許你在測試開始前，先把預先定義的數據，填充到測試資料庫裡面，夾具(Fixtures)獨立於資料庫，並且用YAML書寫，每個 Model 都有一個檔案。
_Fixtures_ is a fancy word for sample data. Fixtures allow you to populate your testing database with predefined data before your tests run. Fixtures are database independent and written in YAML. There is one file per model.

備註：夾具(Fixtures)不是被設計來創造你測試需要的每個物件，並且當只有給在常見的案例中被應用的預設數據使用時，最好被管理
NOTE: Fixtures are not designed to create every object that your tests need, and are best managed when only used for default data that can be applied to the common case.


你可以在 `test/fixtures` 這個資料夾下面找到夾具(fixtures)，當你執行 `bin/rails generate model` 創造model的時候，Rails會自動在這個資料夾裡面創建 `fixture stubs` 。
You'll find fixtures under your `test/fixtures` directory. When you run `bin/rails generate model` to create a new model, Rails automatically creates fixture stubs in this directory.

#### YAML

YAML格式夾具(fixtures)是一個描述你的樣本資料人性化的方式，這個格式的副檔名是 **.yml** (像是 `users.yml`)。
YAML-formatted fixtures are a human-friendly way to describe your sample data. These types of fixtures have the **.yml** file extension (as in `users.yml`).

下面是YAML的樣本夾具(fixture)檔案
Here's a sample YAML fixture file:

```yaml
# lo & behold! I am a YAML comment!
david:
  name: David Heinemeier Hansson
  birthday: 1979-10-15
  profession: Systems development

steve:
  name: Steve Ross Kellock
  birthday: 1974-09-27
  profession: guy with keyboard
```

每個夾具(fixture)被賦予一個名稱，該名稱後面跟著冒號分隔著的鍵/值的縮進列表。記錄通常有空格來做分行，你可以在第一行用 # 字號的方式把註解加進夾具(fixture)檔案中。
Each fixture is given a name followed by an indented list of colon-separated key/value pairs. Records are typically separated by a blank line. You can place comments in a fixture file by using the # character in the first column.

如果你正在運行[associations](/association_basics.html)，你可以在兩個夾具(fixtures)間定義一個參考節點，這裡有個 `belongs_to`/`has_many`  關聯的例子。
If you are working with [associations](/association_basics.html), you can
define a reference node between two different fixtures. Here's an example with
a `belongs_to`/`has_many` association:

```yaml
# test/fixtures/categories.yml
about:
  name: About
```

```yaml
# test/fixtures/articles.yml
first:
  title: Welcome to Rails!
  category: about
```

```yaml
# test/fixtures/action_text/rich_texts.yml
first_content:
  record: first (Article)
  name: content
  body: <div>Hello, from <strong>a fixture</strong></div>
```

注意到在 `fixtures/articles.yml` 裡面，可以找到 `first` 裡面有一個鍵值是 `category`/`about` 的，還有 `fixtures/action_text/rich_texts.yml` 裡的 `first_content` 有一個鍵值是 `record`/`first (Article)` 的，這代表Active Record會為前者加載在 `fixtures/categories.yml` 中的 `about` 裡面，為後者加載在 `fixtures/articles.yml` 中的 `first` 裡面。
Notice the `category` key of the `first` Article found in `fixtures/articles.yml` has a value of `about`, and that the `record` key of the `first_content` entry found in `fixtures/action_text/rich_texts.yml` has a value of `first (Article)`. This hints to Active Record to load the Category `about` found in `fixtures/categories.yml` for the former, and Action Text to load the Article `first` found in `fixtures/articles.yml` for the latter.

備註： 對於透過名稱相互引用的關聯，你可以使用夾具名稱，而不是在關連的夾具上指定 `id:` 屬性，Rails將會自動分配一個主鍵以便在運行間保持一致，有關關聯行為的更多資訊，請閱讀這個文件[Fixtures API documentation](https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html)。
NOTE: For associations to reference one another by name, you can use the fixture name instead of specifying the `id:` attribute on the associated fixtures. Rails will auto assign a primary key to be consistent between runs. For more information on this association behavior please read the [Fixtures API documentation](https://api.rubyonrails.org/classes/ActiveRecord/FixtureSet.html).


#### File Attachment Fixtures
#### 文件附件夾具(Fixtures)

就跟其他Active Record支持的models一樣，Active Storage附件紀錄繼承自 `ActiveRecord::Base` 實體，因此可以由夾具(Fixtures)填充。
Like other Active Record-backed models, Active Storage attachment records
inherit from ActiveRecord::Base instances and can therefore be populated by
fixtures.

考慮 `Article` 的model，他跟圖片有一個 `thumbnail` 附件的關聯，以及夾具(Fixtures)數據YAML：
Consider an `Article` model that has an associated image as a `thumbnail`
attachment, along with fixture data YAML:

```ruby
class Article
  has_one_attached :thumbnail
end
```

```yaml
# test/fixtures/articles.yml
first:
  title: An Article
```
假設在 `test/fixtures/files/first.png` 中有一個 [image/png][] 的編碼文件，下面的YAML夾具條目(YAML fixture entries)將會產生跟 `ActiveStorage::Blob` 和 `ActiveStorage::Attachment` 相關的紀錄。
Assuming that there is an [image/png][] encoded file at
`test/fixtures/files/first.png`, the following YAML fixture entries will
generate the related `ActiveStorage::Blob` and `ActiveStorage::Attachment`
records:

```yaml
# test/fixtures/active_storage/blobs.yml
first_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob filename: "first.png" %>
```

```yaml
# test/fixtures/active_storage/attachments.yml
first_thumbnail_attachment:
  name: thumbnail
  record: first (Article)
  blob: first_thumbnail_blob
```

[image/png]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types

#### ERB'in It Up

ERB檔案可以讓你透過範例鑲嵌Ruby的程式碼，當Rails加載夾具(Fixtures)的時候，YAML夾具(Fixtures)格式會用ERB來做預先處理。這可以讓你使用Ruby來幫助你產生一些樣本檔案，例如，下面的程式碼會生成1000個使用者。
ERB allows you to embed Ruby code within templates. The YAML fixture format is pre-processed with ERB when Rails loads fixtures. This allows you to use Ruby to help you generate some sample data. For example, the following code generates a thousand users:

```erb
<% 1000.times do |n| %>
user_<%= n %>:
  username: <%= "user#{n}" %>
  email: <%= "user#{n}@example.com" %>
<% end %>
```

#### 夾具(Fixtures) in Action

預設情況下，Rails會自動從 `test/fixtures` 資料夾載入所有的夾具(fixtures)，載入包含三個步驟：
Rails automatically loads all fixtures from the `test/fixtures` directory by
default. Loading involves three steps:

1. 從夾具(fixture)相對應的資料表(table)中，刪除已經存在的資料
2. 把夾具資料(fixture data)載入資料表(table)
3. 將夾具資料存在方法中，以防你直接去只用他

1. Remove any existing data from the table corresponding to the fixture
2. Load the fixture data into the table
3. Dump the fixture data into a method in case you want to access it directly

提示：為了防止從資料庫刪除現存的資料，Rails嘗試禁止引用完整觸發器(像是外鍵、檢查限制)，如果你在跑測試的時候遇到煩人的驗證錯誤，確保資料庫的使用者有權限在測試環境中禁用這些觸發器。(在PostgreSQL，只有超級用戶可以禁用所有觸發器，閱讀更多的PostgreSQL權限設定[here](https://www.postgresql.org/docs/current/sql-altertable.html))。)

TIP: In order to remove existing data from the database, Rails tries to disable referential integrity triggers (like foreign keys and check constraints). If you are getting annoying permission errors on running tests, make sure the database user has privilege to disable these triggers in testing environment. (In PostgreSQL, only superusers can disable all triggers. Read more about PostgreSQL permissions [here](https://www.postgresql.org/docs/current/sql-altertable.html)).

#### 夾具(Fixtures) 是 Active Record 的物件

夾具(Fixtures)是 `Active Record` 的實體，正如上面的第三點所述，你可以直接使用這個物件，因為作為一個範圍(scope)是測試用例本地範圍的方法，他是自動可以使用的。例如：
Fixtures are instances of Active Record. As mentioned in point #3 above, you can access the object directly because it is automatically available as a method whose scope is local of the test case. For example:

```ruby
# this will return the User object for the fixture named david
users(:david)

# this will return the property for david called id
users(:david).id

# one can also access methods available on the User class
david = users(:david)
david.call(david.partner)
```

要一次獲得多個夾具(fixtures)，你可以傳入多個夾具(fixture)名稱，例如：
To get multiple fixtures at once, you can pass in a list of fixture names. For example:


```ruby
# this will return an array containing the fixtures david and steve
users(:david, :steve)
```


Model Testing
-------------

Model測試用於測試你應用程式中的多種models。
Model tests are used to test the various models of your application.

Rails model 測試被存於 `test/models` 資料夾的下方，Rails提供一個生成器來幫助你創造model測試的框架。
Rails model tests are stored under the `test/models` directory. Rails provides
a generator to create a model test skeleton for you.

```bash
$ bin/rails generate test_unit:model article title:string body:text
create  test/models/article_test.rb
create  test/fixtures/articles.yml
```

Model測試沒有像 `ActionMailer::TestCase` 有自己的 `superclass`，相反的，他們繼承自[`ActiveSupport::TestCase`](https://api.rubyonrails.org/classes/ActiveSupport/TestCase.html)。
Model tests don't have their own superclass like `ActionMailer::TestCase`. Instead, they inherit from [`ActiveSupport::TestCase`](https://api.rubyonrails.org/classes/ActiveSupport/TestCase.html).

系統測試 System Testing
--------------

系統測試允許你讓你測試使用者和你的應用程式進行互動，是在真實或無頭瀏覽器中進行測試，系統測試在底層使用 `Capybara` 。
System tests allow you to test user interactions with your application, running tests
in either a real or a headless browser. System tests use Capybara under the hood.

要創建Rails的系統測試，你可以在應用程式中使用 `test/system` 資料夾，Rails提供一個生成器來幫助你創建一個系統測試的框架。
For creating Rails system tests, you use the `test/system` directory in your
application. Rails provides a generator to create a system test skeleton for you.

```bash
$ bin/rails generate system_test users
      invoke test_unit
      create test/system/users_test.rb
```

這是新生成系統測試的樣子：
Here's what a freshly generated system test looks like:

```ruby
require "application_system_test_case"

class UsersTest < ApplicationSystemTestCase
  # test "visiting the index" do
  #   visit users_url
  #
  #   assert_selector "h1", text: "Users"
  # end
end
```

預設情況下，系統測試會在 `Selenium driver` 運行，並且使用Chrome瀏覽器，螢幕大小為 1400X1400，下一個部分會解釋如何更改預設設定。
By default, system tests are run with the Selenium driver, using the Chrome
browser, and a screen size of 1400x1400. The next section explains how to
change the default settings.

### Changing the Default Settings
### 改變預設設定

Rails讓改變系統測試的預設設定變得很簡單，所有設定都被抽象出來，因此你可以專注於寫測試。
Rails makes changing the default settings for system tests very simple. All
the setup is abstracted away so you can focus on writing your tests.

當妳生成一個應用程式或者是 `scaffold` 時，會在測試資料夾創造`application_system_test_case.rb` 這個檔案，這是所有你的系統設定都會有的。
When you generate a new application or scaffold, an `application_system_test_case.rb` file
is created in the test directory. This is where all the configuration for your
system tests should live.

如果你想要改變預設設定，你可以改變系統測試是由什麼來驅動(driven by)，假設你想由 `Selenium` 改成 `Cuprite` 驅動，首先加這個 `cuprite` gem到gemfile，然後到 `application_system_test_case.rb` 這個檔案加下面這一句：
If you want to change the default settings you can change what the system
tests are "driven by". Say you want to change the driver from Selenium to
Cuprite. First add the `cuprite` gem to your `Gemfile`. Then in your
`application_system_test_case.rb` file do the following:

```ruby
require "test_helper"
require "capybara/cuprite"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :cuprite
end
```

驅動名稱 `driven_by` 是必要新增的參數，而 `driven_by` 的參數傳給瀏覽器是用於 `:using`(這個只有Selenium使用)， `:screen_size` 是改變螢幕大小，`:options` 是被用來設定驅動支援的選項。
The driver name is a required argument for `driven_by`. The optional arguments
that can be passed to `driven_by` are `:using` for the browser (this will only
be used by Selenium), `:screen_size` to change the size of the screen for
screenshots, and `:options` which can be used to set options supported by the
driver.

```ruby
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :selenium, using: :firefox
end
```

如果你想要使用無頭瀏覽器，你可以用 在 `:using` 引數的地方加上 `headless_chrome` 或是 `headless_firefox`，這樣可以新增無頭Chrome或者是無頭Firefox瀏覽器。
If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding
`headless_chrome` or `headless_firefox` in the `:using` argument.

```ruby
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome
end
```
如果你想要使用遠端瀏覽器，像是[Headless Chrome in Docker](https://github.com/SeleniumHQ/docker-selenium)，你必須透過 `options` 使用 遠端 `url`。
If you want to use a remote browser, e.g.
[Headless Chrome in Docker](https://github.com/SeleniumHQ/docker-selenium),
you have to add remote `url` through `options`.

```ruby
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  options = ENV["SELENIUM_REMOTE_URL"].present? ? { url: ENV["SELENIUM_REMOTE_URL"] } : {}
  driven_by :selenium, using: :headless_chrome, options: options
end
```
像這樣的案例， `webdrivers` 這個gem就不再需要required，你應該需要完全移除他，或是在 `Gemfile` 那邊增加 `require:`
In such a case, the gem `webdrivers` is no longer required. You could remove it
completely or add `require:` option in `Gemfile`.

```ruby
# ...
group :test do
  gem "webdrivers", require: !ENV["SELENIUM_REMOTE_URL"] || ENV["SELENIUM_REMOTE_URL"].empty?
end
```

現在應該可以成功連結遠端瀏覽器。
Now you should get a connection to remote browser.

```bash
$ SELENIUM_REMOTE_URL=http://localhost:4444/wd/hub bin/rails test:system
```
如果你的應用程式在測試的時候是跑遠端，像是 `Docker container`， `Capybara` 需要更多關於 [call remote servers](https://github.com/teamcapybara/capybara#calling-remote-servers) 的資訊。
If your application in test is running remote too, e.g. Docker container,
Capybara needs more input about how to
[call remote servers](https://github.com/teamcapybara/capybara#calling-remote-servers).

```ruby
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  def setup
    Capybara.server_host = "0.0.0.0" # bind to all interfaces
    Capybara.app_host = "http://#{IPSocket.getaddress(Socket.gethostname)}" if ENV["SELENIUM_REMOTE_URL"].present?
    super
  end
  # ...
end
```
現在你應該成功連結遠端瀏覽器和伺服器了，無論他是在 `Docker container` 或是在 `CI` 中執行。
Now you should get a connection to remote browser and server, regardless if it
is running in Docker container or CI.


如果今天你的 `Capybara` 設定比Rails還要多，可以把額外設定都加進 `application_system_test_case.rb` 這個檔案裡面。
If your Capybara configuration requires more setup than provided by Rails, this
additional configuration could be added into the `application_system_test_case.rb`
file.

請看 [Capybara's documentation](https://github.com/teamcapybara/capybara#setup) 有更多的額外設定。
Please see [Capybara's documentation](https://github.com/teamcapybara/capybara#setup)
for additional settings.

### Screenshot Helper
### 截圖幫手

`ScreenshotHelper` 是一個被設計來幫你的測試捕捉截圖的小幫手，這有助於測試失敗時看到瀏覽器的畫面，或是查看截圖來debugging。
The `ScreenshotHelper` is a helper designed to capture screenshots of your tests.
This can be helpful for viewing the browser at the point a test failed, or
to view screenshots later for debugging.

這邊提供兩個方法： `take_screenshot` 和 `take_failed_screenshot`， `take_failed_screenshot` 是自動包含在Rails裡面的 `before_teardown` ， `take_screenshot` 輔助方法可以包含在你測試中的任何位置，以擷取瀏覽器的畫面。

Two methods are provided: `take_screenshot` and `take_failed_screenshot`.
`take_failed_screenshot` is automatically included in `before_teardown` inside
Rails.

The `take_screenshot` helper method can be included anywhere in your tests to
take a screenshot of the browser.

### Implementing a System Test
### 執行系統測試

現在我們來幫我們的部落格應用程式加系統測試，我們將會拜訪索引頁面(index page)和創造新的部落格文章，來展示如何編寫系統測試。
Now we're going to add a system test to our blog application. We'll demonstrate
writing a system test by visiting the index page and creating a new blog article.

如果使用 `scaffold generator`，系統測試框架會自動產生給你，如果你沒有使用，可以跟著下一面寫來產生框架。
If you used the scaffold generator, a system test skeleton was automatically
created for you. If you didn't use the scaffold generator, start by creating a
system test skeleton.

```bash
$ bin/rails generate system_test articles
```

之後會創造測試檔案給我們，終端機的輸出指令會是下面這樣：
It should have created a test file placeholder for us. With the output of the
previous command you should see:

```
      invoke  test_unit
      create    test/system/articles_test.rb
```

現在讓我打開檔案並且寫下我們第一行的斷言assertion：
Now let's open that file and write our first assertion:

```ruby
require "application_system_test_case"

class ArticlesTest < ApplicationSystemTestCase
  test "viewing the index" do
    visit articles_path
    assert_selector "h1", text: "Articles"
  end
end
```

這個測試應該會看到索引頁面上有一個 `h1`，並且會通過。  
The test should see that there is an `h1` on the articles index page and pass.

執行系統測試。
Run the system tests.  

```bash
$ bin/rails test:system
```

備註：預設下，輸入 `bin/rails test` 不會執行系統測試，確保輸入 `bin/rails test:system` 可以確實執行它們，你也可以輸入 `bin/rails test:all` 來執行全部測試，包括系統測試。
NOTE: By default, running `bin/rails test` won't run your system tests.
Make sure to run `bin/rails test:system` to actually run them.
You can also run `bin/rails test:all` to run all tests, including system tests.

#### Creating Articles System Test
#### 創造文章系統測試

現在來測試一下在我們部落格中新增文章的流程。
Now let's test the flow for creating a new article in our blog.

```ruby
test "should create Article" do
  visit articles_path

  click_on "New Article"

  fill_in "Title", with: "Creating an Article"
  fill_in "Body", with: "Created this article successfully!"

  click_on "Create Article"

  assert_text "Creating an Article"
end
```
第一步先呼叫 `visit articles_path`，這會讓測試進到文章的 `index page`，然後這個 `click_on "New Article"` 將會找到在 `index page` 頁面中，"New Article"的按鈕，這會重導到瀏覽器 `/articles/new` 的連結。
The first step is to call `visit articles_path`. This will take the test to the
articles index page.

然後這個 `click_on "New Article"` 將會找到在 `index page` 頁面中，"New Article"的按鈕，這會重導到瀏覽器 `/articles/new` 的連結
Then the `click_on "New Article"` will find the "New Article" button on the
index page. This will redirect the browser to `/articles/new`.

再來測試將會用指定的文字填進文章中的標題和內容，一旦欄位被填寫，"Create Article" 被點擊，將會送出 `Post request` ，並且在資料庫中新增一個新文章。
Then the test will fill in the title and body of the article with the specified
text. Once the fields are filled in, "Create Article" is clicked on which will
send a POST request to create the new article in the database.

最後我們將會重導到文章的 `index page`，並且我們斷言在文章標題的文字，會在文章中的 `index page` 裡面。
We will be redirected back to the articles index page and there we assert
that the text from the new article's title is on the articles index page.

#### Testing for Multiple Screen Sizes
#### 在不同大小的螢幕測試

如果想要在電腦測試時，多測試不同畫面大小的狀況，你可以創造另外一個繼承自 `SystemTestCase` 而且在測試插件中使用的類別，在這個範例裡面，以下的設定會在 `/test` 資料夾裡面，新增 `mobile_system_test_case.rb` 的檔案
If you want to test for mobile sizes on top of testing for desktop,
you can create another class that inherits from SystemTestCase and use in your
test suite. In this example a file called `mobile_system_test_case.rb` is created
in the `/test` directory with the following configuration.

```ruby
require "test_helper"

class MobileSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :selenium, using: :chrome, screen_size: [375, 667]
end
```

使用這個設定，創造一個繼承自 `MobileSystemTestCase` 且在 `test/system` 的測試，現在你可以在多個不同的螢幕大小測試應用程式。
To use this configuration, create a test inside `test/system` that inherits from `MobileSystemTestCase`.
Now you can test your app using multiple different configurations.

```ruby
require "mobile_system_test_case"

class PostsTest < MobileSystemTestCase

  test "visiting the index" do
    visit posts_url
    assert_selector "h1", text: "Posts"
  end
end
```

#### Taking It Further
#### 更進一步

系統測試美妙的地方就在於他跟整合測試很像，他們都在測試使用者在你的controller、model、view做互動，不過系統測試更完整一點，他會實際上像真正的使用者在使用他一樣，測試你的應用程式，進一步看，你可以測試任何，使用者在應用程式中做的事情，像是評論、刪除文章、刪除草稿文章...等等。

The beauty of system testing is that it is similar to integration testing in
that it tests the user's interaction with your controller, model, and view, but
system testing is much more robust and actually tests your application as if
a real user were using it. Going forward, you can test anything that the user
themselves would do in your application such as commenting, deleting articles,
publishing draft articles, etc.

整合測試 Integration Testing
-------------------

整合測試使用在應用程式中各個部分如何互相互動，他們通常用在測試應用程式的重要工作流程。
Integration tests are used to test how various parts of our application interact. They are generally used to test important workflows within our application.

為了新增Rails的整合測試，我們使用 `test/integration` 資料夾，Rails有提供產生整合測試的框架給我們。
For creating Rails integration tests, we use the `test/integration` directory for our application. Rails provides a generator to create an integration test skeleton for us.

```bash
$ bin/rails generate integration_test user_flows
      exists  test/integration/
      create  test/integration/user_flows_test.rb
```

產生出新的整合測試資料像這樣：
Here's what a freshly generated integration test looks like:

```ruby
require "test_helper"

class UserFlowsTest < ActionDispatch::IntegrationTest
  # test "the truth" do
  #   assert true
  # end
end
```

這裡的測試繼承自 `ActionDispatch::IntegrationTest`，這可以讓我們為整合測試新增一些額外有用的方法。
Here the test is inheriting from `ActionDispatch::IntegrationTest`. This makes some additional helpers available for us to use in our integration tests.

### Helpers Available for Integration Tests
### 用在整合測試的小幫手

除了標準的測試小幫手外，還有從 `ActionDispatch::IntegrationTest` 繼承來一些可以用來編寫整合測試的小幫手，我們來簡單介紹一下可以選擇的三種類型小助手。
In addition to the standard testing helpers, inheriting from `ActionDispatch::IntegrationTest` comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.

有關處理執行整合測試，請看這一篇[`ActionDispatch::Integration::Runner`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/Runner.html)。
For dealing with the integration test runner, see [`ActionDispatch::Integration::Runner`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/Runner.html).

當執行請求時(performing requests)，我們會有 [`ActionDispatch::Integration::RequestHelpers`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html) 這個可以使用。
When performing requests, we will have [`ActionDispatch::Integration::RequestHelpers`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html) available for our use.

如果我們需要修改工作階段(session)或者是整合測試的狀態話，可以看這一篇尋求幫助 [`ActionDispatch::Integration::Session`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/Session.html)。
If we need to modify the session, or state of our integration test, take a look at [`ActionDispatch::Integration::Session`](https://api.rubyonrails.org/classes/ActionDispatch/Integration/Session.html) to help.

### Implementing an Integration Test
### 執行整合測試

讓我們來幫部落格增加一個整合測試，我們將從新增部落格新文章的基本流程開始，來驗證所有流程是否正常運行。
Let's add an integration test to our blog application. We'll start with a basic workflow of creating a new blog article, to verify that everything is working properly.

我們會先從新增整合測試的框架開始：
We'll start by generating our integration test skeleton:

```bash
$ bin/rails generate integration_test blog_flow
```
這樣會創造一個測試資料夾給我們，在終端機看到的輸出指令會像下面：
It should have created a test file placeholder for us. With the output of the
previous command we should see:

```
      invoke  test_unit
      create    test/integration/blog_flow_test.rb
```

現在我們來打開檔案並且寫下第一個斷言：
Now let's open that file and write our first assertion:

```ruby
require "test_helper"

class BlogFlowTest < ActionDispatch::IntegrationTest
  test "can see the welcome page" do
    get "/"
    assert_select "h1", "Welcome#index"
  end
end
```
我們會在"Testing Views"之下，去找 `assert_select` 查詢請求的結果HTML，他藉由斷言關鍵的HTML元素、內容來測試我們請求的回應。
We will take a look at `assert_select` to query the resulting HTML of a request in the "Testing Views" section below. It is used for testing the response of our request by asserting the presence of key HTML elements and their content.

當我們拜訪(visit)根目錄，我們應該會看到 `welcome/index.html.erb` 這個頁面渲染出來，因此斷言應該會通過。
When we visit our root path, we should see `welcome/index.html.erb` rendered for the view. So this assertion should pass.

#### Creating Articles Integration
#### 新增文章整合

如何測試我們在部落格裡面創造新文章並且看到結果的能力，
How about testing our ability to create a new article in our blog and see the resulting article.

```ruby
test "can create an article" do
  get "/articles/new"
  assert_response :success

  post "/articles",
    params: { article: { title: "can create", body: "article successfully." } }
  assert_response :redirect
  follow_redirect!
  assert_response :success
  assert_select "p", "Title:\n  can create"
end
```
讓我們拆解這個測試，來讓我們理解他。
Let's break this test down so we can understand it.

一開始先在文章的 `controller`  呼叫 `:new` 的 `action`，這個回應應該要成功。
We start by calling the `:new` action on our Articles controller. This response should be successful.

之後會給一個 `post` 的需求到我們文章 `controller` 的 `:create action` 。
After this we make a post request to the `:create` action of our Articles controller:

```ruby
post "/articles",
  params: { article: { title: "can create", body: "article successfully." } }
assert_response :redirect
follow_redirect!
```

這兩行的意思是，當我們創造新的文章，會有一個處理重導的設置。
The two lines following the request are to handle the redirect we setup when creating a new article.

標註：別忘了呼叫 `follow_redirect`，如果你計畫在重導後發出後續的請求。
NOTE: Don't forget to call `follow_redirect!` if you plan to make subsequent requests after a redirect is made.

最後我們可以斷言我們的回應是成功的，並且我們的新文章在頁面上是可讀的。
Finally we can assert that our response was successful and our new article is readable on the page.

#### Taking It Further
#### 更進一步

我們可以拜訪我們的部落格來成功測試非常小部分的工作流程和創造下新的文章，如果你想要更進一步，我們可以新增評論、移除文章、編輯文章的測試，整合測試是為應用程式實驗各種用力的好地方。
We were able to successfully test a very small workflow for visiting our blog and creating a new article. If we wanted to take this further we could add tests for commenting, removing articles, or editing comments. Integration tests are a great place to experiment with all kinds of use cases for our applications.


Controller的功能測試(Functional Tests for Your Controllers)
-------------------------------------
在Rails，測試多種 `controller 的 actions` 是一種編寫功能測試的形式，記得你的 `controller` 處理你應用程式即將到來的網站請求，並且最後回應、渲染到頁面上，當你寫功能測試時，你正在測試你的操做如何處理請求和預期結果或回應，在某些用例下是 `HTML view`。
In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view.

### What to Include in Your Functional Tests
### 功能測試應該包含哪些內容

你應該測試的內容有這些：
You should test for things such as:


* was the web request successful?
* 網站請求是否有成功？
* was the user redirected to the right page?
* 使用者是否被重導到正確的頁面？
* was the user successfully authenticated?
* 使用者是否成功通過身份驗證？
* was the appropriate message displayed to the user in the view?
* 是否在 `view` 中成功顯示了適當的訊息？
* was the correct information displayed in the response?
* 回應中是否有顯示正確的資訊？

查看功能測試最簡單的方式，就是使用框架生產器來產生 `controller`：
The easiest way to see functional tests in action is to generate a controller using the scaffold generator:

```bash
$ bin/rails generate scaffold_controller article title:string body:text
...
create  app/controllers/articles_controller.rb
...
invoke  test_unit
create    test/controllers/articles_controller_test.rb
...
```
這會產生 `controller code` 和測試 `Article` 的資源。你可以查看在 `test/controllers` 資料夾中的 `articles_controller_test.rb` 文件。
This will generate the controller code and tests for an `Article` resource.
You can take a look at the file `articles_controller_test.rb` in the `test/controllers` directory.

如果你已經有 `controller` 並且只想產生7個測試框架的程式碼給7個預設的 `actions`，你可以輸入下面的程式碼。
If you already have a controller and just want to generate the test scaffold code for
each of the seven default actions, you can use the following command:

```bash
$ bin/rails generate test_unit:scaffold article
...
invoke  test_unit
create    test/controllers/articles_controller_test.rb
...
```

讓我們查看這個測試，在 `articles_controller_test.rb` 檔案裡面的 `test_should_get_index`。   
Let's take a look at one such test, `test_should_get_index` from the file `articles_controller_test.rb`.

```ruby
# articles_controller_test.rb
class ArticlesControllerTest < ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url
    assert_response :success
  end
end
```
在 `test_should_get_index` 這個測試裡面，Rails模擬 `action` 是 `index` 的請求，卻了請求成功並且確保可以生成正確的回應主體。
In the `test_should_get_index` test, Rails simulates a request on the action called `index`, making sure the request was successful
and also ensuring that the right response body has been generated.

`get` 方法啟動網站請求，並且填充結果到 `@response`，他最多可以接受六個引數：
The `get` method kicks off the web request and populates the results into the `@response`. It can accept up to 6 arguments:

* 你請求 `controller action` 的URI，他可以是字串的形式或是路徑小幫手(e.g. `articles_url`)。
* `params`：帶有參數請求 `hash` 的選項可以傳遞給 `action`。
* `headers`：用於會隨著請求傳遞的標頭
* `env`：用於根據需要自定義請求環境
* `xhr`：請求是否為 `Ajax` 糗球，可以設定為true來幫請求標記為 `Ajax`
* `as`：用於對不同類型的內容作編碼的請求

* The URI of the controller action you are requesting.
  This can be in the form of a string or a route helper (e.g. `articles_url`).
* `params`: option with a hash of request parameters to pass into the action
  (e.g. query string parameters or article variables).
* `headers`: for setting the headers that will be passed with the request.
* `env`: for customizing the request environment as needed.
* `xhr`: whether the request is Ajax request or not. Can be set to true for marking the request as Ajax.
* `as`: for encoding the request with different content type.

這些的關鍵字引數都是可選擇的。
All of these keyword arguments are optional.

例如：為第一個 `Article` 呼叫 `:show` 的 `action`，傳入 `HTTP_REFERER` 的標頭：
Example: Calling the `:show` action for the first `Article`, passing in an `HTTP_REFERER` header:

```ruby
get article_url(Article.first), headers: { "HTTP_REFERER" => "http://example.com/home" }
```

另一個例子：為最後的 `Article` 呼叫 `:update` 的 `action`，傳進新的文字，用 `Ajax` 請求，在 `params` 為 `title` 傳進新的文本：
Another example: Calling the `:update` action for the last `Article`, passing in new text for the `title` in `params`, as an Ajax request:

```ruby
patch article_url(Article.last), params: { article: { title: "updated" } }, xhr: true
```

再一個例子： 呼叫 `:create` 的 `action` 來創造新的文章，用 `JSON` 請求，在 `params` 為 `title` 傳進新的文本：
One more example: Calling the `:create` action to create a new article, passing in
text for the `title` in `params`, as JSON request:

```ruby
post articles_path, params: { article: { title: "Ahoy!" } }, as: :json
```
備註： 如果嘗試從 `articles_controller_test` 執行 `test_should_create_article` 測試，他會因為新添加的 `model` 級別驗證，導致測試失敗，這是正確的。
NOTE: If you try running `test_should_create_article` test from `articles_controller_test.rb` it will fail on account of the newly added model level validation and rightly so.

讓我們來修改 `articles_controller_test.rb` 裡的 `test_should_create_article`，照下面修改就可以通過了：
Let us modify `test_should_create_article` test in `articles_controller_test.rb` so that all our test pass:

```ruby
test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }
  end

  assert_redirected_to article_path(Article.last)
end
```
現在你可以嘗試執行所有測試，他們應該都會通過。
Now you can try running all the tests and they should pass.

備註：如果遵循 [Basic Authentication](getting_started.html#basic-authentication) 裡面部分的步驟，你將需要為每個請求標頭增加驗證才能讓所有測試通過：
NOTE: If you followed the steps in the [Basic Authentication](getting_started.html#basic-authentication) section, you'll need to add authorization to every request header to get all the tests passing:

```ruby
post articles_url, params: { article: { body: "Rails is awesome!", title: "Hello Rails" } }, headers: { Authorization: ActionController::HttpAuthentication::Basic.encode_credentials("dhh", "secret") }
```

### Available Request Types for Functional Tests
### 功能測試中的請求類型

如果你熟悉HTTP協議的話，會知道 `get` 是一種請求類型，Rails功能測試中可以使用六種請求：
If you're familiar with the HTTP protocol, you'll know that `get` is a type of request. There are 6 request types supported in Rails functional tests:

* `get`
* `post`
* `patch`
* `put`
* `head`
* `delete`

這幾種請求都要相對應的方法使用，在常見的CRUD中，最常使用的是 `get` 、 `post` 、 `put` 和 `delete`。
All of request types have equivalent methods that you can use. In a typical C.R.U.D. application you'll be using `get`, `post`, `put`, and `delete` more often.

備註： 功能測試不驗證 `action` 是否接受指定的請求類型，我們關注的是請求的結果，如果想要做到這樣的測試，可以做請求測試(request test)。
NOTE: Functional tests do not verify whether the specified request type is accepted by the action, we're more concerned with the result. Request tests exist for this use case to make your tests more purposeful.

### Testing XHR (Ajax) Requests
### 測試 XHR (Ajax) 請求

測試 Ajax 請求，可以在 `get` 、 `post` 、 `patch` 、 `put` 和 `delete` 方法中設定 `xhr: true` 選項，例如：
To test Ajax requests, you can specify the `xhr: true` option to `get`, `post`,
`patch`, `put`, and `delete` methods. For example:

```ruby
test "ajax request" do
  article = articles(:one)
  get article_url(article), xhr: true

  assert_equal "hello world", @response.body
  assert_equal "text/javascript", @response.media_type
end
```

### The Three Hashes of the Apocalypse

在三個需求被達成或處理後，你會有三個 `hash` 物件可以使用：
After a request has been made and processed, you will have 3 Hash objects ready for use:


* `cookies` - 設定cookies
* `flash` - 任何在 `flash` 中的物件
* `session` - 任何在工作階段變數的物件

* `cookies` - Any cookies that are set
* `flash` - Any objects living in the flash
* `session` - Any object living in session variables

和普通 `HASH` 物件一樣，你可以使用字串的鍵值來獲取相對應的值，另外，你也可以使用符號來獲得值，例如：
As is the case with normal Hash objects, you can access the values by referencing the keys by string. You can also reference them by symbol name. For example:

```ruby
flash["gordon"]               flash[:gordon]
session["shmession"]          session[:shmession]
cookies["are_good_for_u"]     cookies[:are_good_for_u]
```

### Instance Variables Available
### 可用的實體變數

在 `request` 之後，功能測試你一樣可以使用三個實體變數
You also have access to three instance variables in your functional tests, after a request is made:

* `@controller` - 處理請求 `controller`
* `@request` - 請求物件
* `@response` - 回應物件

* `@controller` - The controller processing the request
* `@request` - The request object
* `@response` - The response object


```ruby
class ArticlesControllerTest < ActionDispatch::IntegrationTest
  test "should get index" do
    get articles_url

    assert_equal "index", @controller.action_name
    assert_equal "application/x-www-form-urlencoded", @request.media_type
    assert_match "Articles", @response.body
  end
end
```

### Setting Headers and CGI Variables
### 設定標頭和CGI變數


[HTTP headers](https://tools.ietf.org/search/rfc2616#section-5.3) 和 [CGI variables](https://tools.ietf.org/search/rfc3875#section-4.1) 可以透過 `headers` 參數傳入：

```ruby
# setting an HTTP Header
get articles_url, headers: { "Content-Type": "text/plain" } # simulate the request with custom header

# setting a CGI variable
get articles_url, headers: { "HTTP_REFERER": "http://example.com/home" } # simulate the request with custom env variable
```

### Testing `flash` Notices
### 測試 `flash` 訊息

如果你記得前面說的，在三個 `hash` 中有一個是 `flash`。
If you remember from earlier, one of the Three Hashes of the Apocalypse was `flash`.

我們想要在某人成功新增新的文章後，增加 `flash` 訊息到我們的部落格。
We want to add a `flash` message to our blog application whenever someone
successfully creates a new Article.

讓我們開始新增斷言到我們的 `test_should_create_article` 測試裡面：
Let's start by adding this assertion to our `test_should_create_article` test:

```ruby
test "should create article" do
  assert_difference("Article.count") do
    post articles_url, params: { article: { title: "Some title" } }
  end

  assert_redirected_to article_path(Article.last)
  assert_equal "Article was successfully created.", flash[:notice]
end
```
如果你想要跑測試，我們會看到失敗
If we run our test now, we should see a failure:

```bash
$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
Run options: -n test_should_create_article --seed 32266

# Running:

F

Finished in 0.114870s, 8.7055 runs/s, 34.8220 assertions/s.

  1) Failure:
ArticlesControllerTest#test_should_create_article [/test/controllers/articles_controller_test.rb:16]:
--- expected
+++ actual
@@ -1 +1 @@
-"Article was successfully created."
+nil

1 runs, 4 assertions, 1 failures, 0 errors, 0 skips
```
讓我們來增加 `flash` 訊息到我們的 `controller`，加上去後，我們的 `:create action` 會看起來像這樣：
Let's implement the flash message now in our controller. Our `:create` action should now look like this:

```ruby
def create
  @article = Article.new(article_params)

  if @article.save
    flash[:notice] = "Article was successfully created."
    redirect_to @article
  else
    render "new"
  end
end
```

現在再跑一次測試，可以看到通過了：
Now if we run our tests, we should see it pass:

```bash
$ bin/rails test test/controllers/articles_controller_test.rb -n test_should_create_article
Run options: -n test_should_create_article --seed 18981

# Running:

.

Finished in 0.081972s, 12.1993 runs/s, 48.7972 assertions/s.

1 runs, 4 assertions, 0 failures, 0 errors, 0 skips
```

### Putting It Together
### 一起測試多個action

到現在為止，我們測試了文章 `controller` 的 `:index` 、 `:new` 、 `:create` ，我們要怎麼處理現有的數據？
At this point our Articles controller tests the `:index` as well as `:new` and `:create` actions. What about dealing with existing data?

我們來寫一下 `:show` 的測試：
Let's write a test for the `:show` action:

```ruby
test "should show article" do
  article = articles(:one)
  get article_url(article)
  assert_response :success
end
```
還記得我們前面對夾具(fixtures)的討論嗎？ 我們可以使用 `articles()` 方法去使用 Articles 夾具(fixtures)。
Remember from our discussion earlier on fixtures, the `articles()` method will give us access to our Articles fixtures.

那如何刪除已經存在的文章呢？
How about deleting an existing Article?

```ruby
test "should destroy article" do
  article = articles(:one)
  assert_difference("Article.count", -1) do
    delete article_url(article)
  end

  assert_redirected_to articles_path
end
```
我們來增加一個更新已經存在的測試。
We can also add a test for updating an existing Article.

```ruby
test "should update article" do
  article = articles(:one)

  patch article_url(article), params: { article: { title: "updated" } }

  assert_redirected_to article_path(article)
  # Reload association to fetch updated data and assert that title is updated.
  article.reload
  assert_equal "updated", article.title
end
```
注意我們在這三個測試中開始看到有重複的地方了，他們都用了同一個夾具(fixture)的數據，避免重複，我們可以使用 `ActiveSupport::Callbacks` 提供的 `setup` 和 `teardown` 方法。
Notice we're starting to see some duplication in these three tests, they both access the same Article fixture data. We can D.R.Y. this up by using the `setup` and `teardown` methods provided by `ActiveSupport::Callbacks`.

為了簡潔，現在先忽略其他測試。我們測試應該如下所示：
Our test should now look something as what follows. Disregard the other tests for now, we're leaving them out for brevity.

```ruby
require "test_helper"

class ArticlesControllerTest < ActionDispatch::IntegrationTest
  # called before every single test
  setup do
    @article = articles(:one)
  end

  # called after every single test
  teardown do
    # when controller is using cache it may be a good idea to reset it afterwards
    Rails.cache.clear
  end

  test "should show article" do
    # Reuse the @article instance variable from setup
    get article_url(@article)
    assert_response :success
  end

  test "should destroy article" do
    assert_difference("Article.count", -1) do
      delete article_url(@article)
    end

    assert_redirected_to articles_path
  end

  test "should update article" do
    patch article_url(@article), params: { article: { title: "updated" } }

    assert_redirected_to article_path(@article)
    # Reload association to fetch updated data and assert that title is updated.
    @article.reload
    assert_equal "updated", @article.title
  end
end
```

跟Rails其他的 `callbacks` 一樣， `setup` 和 `teardown` 方法都可以支援區塊、lambda、符號形式的方法命名。
Similar to other callbacks in Rails, the `setup` and `teardown` methods can also be used by passing a block, lambda, or method name as a symbol to call.

### Test Helpers
### 測試小幫手

避免程式碼重複，你可以增加你自己的測試小幫手，下面有一個登入的小幫手範例：
To avoid code duplication, you can add your own test helpers.
Sign in helper can be a good example:

```ruby
# test/test_helper.rb

module SignInHelper
  def sign_in_as(user)
    post sign_in_url(email: user.email, password: user.password)
  end
end

class ActionDispatch::IntegrationTest
  include SignInHelper
end
```

```ruby
require "test_helper"

class ProfileControllerTest < ActionDispatch::IntegrationTest

  test "should show profile" do
    # helper is now reusable from any controller test case
    sign_in_as users(:david)

    get profile_url
    assert_response :success
  end
end
```

#### Using Separate Files
#### 使用分開的檔案

如果你的小幫手讓你的 `test_helper.rb` 變得混亂，你可以把他們提取到單獨的文件中，儲存的好地方就是 `test/lib` 或是 `test/test_helpers`。
If you find your helpers are cluttering `test_helper.rb`, you can extract them into separate files.
One good place to store them is `test/lib` or `test/test_helpers`.

```ruby
# test/test_helpers/multiple_assertions.rb
module MultipleAssertions
  def assert_multiple_of_forty_two(number)
    assert (number % 42 == 0), "expected #{number} to be a multiple of 42"
  end
end
```
這些小幫手可以根據需求被明確的被需要和被引入。
These helpers can then be explicitly required as needed and included as needed

```ruby
require "test_helper"
require "test_helpers/multiple_assertions"

class NumberTest < ActiveSupport::TestCase
  include MultipleAssertions

  test "420 is a multiple of forty two" do
    assert_multiple_of_forty_two 420
  end
end
```
或者他們可以值接在父類別中被引用
or they can continue to be included directly into the relevant parent classes

```ruby
# test/test_helper.rb
require "test_helpers/sign_in_helper"

class ActionDispatch::IntegrationTest
  include SignInHelper
end
```

#### Eagerly Requiring Helpers
#### 積極地引入小幫手

你可以在 `test_helper.rb` 這邊積極的引入小幫手，這樣很方便的找到他，因此你的測試檔案可以很隱晦地去使用它們，這邊可以使用 `globbing` 來完成，就像下面：
You may find it convenient to eagerly require helpers in `test_helper.rb` so your test files have implicit access to them. This can be accomplished using globbing, as follows

```ruby
# test/test_helper.rb
Dir[Rails.root.join("test", "test_helpers", "**", "*.rb")].each { |file| require file }
```

這樣會有增加啟動時間的缺點，而不是手動在你個人測試中引入需要的檔案。
This has the downside of increasing the boot-up time, as opposed to manually requiring only the necessary files in your individual tests.

測試路徑 Testing Routes
--------------

就像跟其他Rails應用程式一樣，你可以測試路徑，路徑測試在 `test/controllers/` 或者部分在 `controller` 測試裡面。
Like everything else in your Rails application, you can test your routes. Route tests reside in `test/controllers/` or are part of controller tests.

備註： 如果你的應用程式有很複雜的路徑，Rails提供一個很好用的測試小幫手來測試他們。
NOTE: If your application has complex routes, Rails provides a number of useful helpers to test them.

關於Rails中，更多可用的路徑斷言，可以看這個API文件 [`ActionDispatch::Assertions::RoutingAssertions`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html)。
For more information on routing assertions available in Rails, see the API documentation for [`ActionDispatch::Assertions::RoutingAssertions`](https://api.rubyonrails.org/classes/ActionDispatch/Assertions/RoutingAssertions.html).


測試畫面 Testing Views
-------------
測試請求中，藉由斷言(assert)關鍵HTML元素的存在和內容，是一個在你測試應用程式畫面(views)中很常見的方式，就像路徑測試，畫面(views)測試在 `test/controllers/`，或者一部分在 `controller` 測試裡面， `assert_select` ，這個方法允許你查詢藉由使用簡單且強大的語法，去查詢回應的HTML元素。
Testing the response to your request by asserting the presence of key HTML elements and their content is a common way to test the views of your application. Like route tests, view tests reside in `test/controllers/` or are part of controller tests. The `assert_select` method allows you to query HTML elements of the response by using a simple yet powerful syntax.

有兩種形式的 `assert_select`：
There are two forms of `assert_select`:

`assert_select(selector, [equality], [message])` 測試通過選擇器上所選的元素和你設定的情況是相等的， `selector` 可以是CSS選擇表達式（字符串），或者是有代入值的表達式。
`assert_select(selector, [equality], [message])` ensures that the equality condition is met on the selected elements through the selector. The selector may be a CSS selector expression (String) or an expression with substitution values.


`assert_select(element, selector, [equality], [message])` 測試所有選擇器的元素從 `_element_` (`Nokogiri::XML::Node` 的實體或是`Nokogiri::XML::NodeSet`) 和他們的子代。
`assert_select(element, selector, [equality], [message])` ensures that the equality condition is met on all the selected elements through the selector starting from the _element_ (instance of `Nokogiri::XML::Node` or `Nokogiri::XML::NodeSet`) and its descendants.

例如，你可以驗證你回應中，標題元素裡面的內容。
For example, you could verify the contents on the title element in your response with:

```ruby
assert_select "title", "Welcome to Rails Testing Guide"
```

你也可以用嵌套 `assert_select` 區塊，為了達到更深入的調查
You can also use nested `assert_select` blocks for deeper investigation.

在下面的範例，內層的 `assert_select` 區塊，會在外層區塊選中的元素集合中，查詢 `li.menu_item` 這個元素。
In the following example, the inner `assert_select` for `li.menu_item` runs
within the collection of elements selected by the outer block:

```ruby
assert_select "ul.navigation" do
  assert_select "li.menu_item"
end
```

除此之外，還可以遍歷外層 assert_select 選中的元素集合，這樣就可以在集合的每個元素上運行內層 assert_select 了。
A collection of selected elements may be iterated through so that `assert_select` may be called separately for each element.

例如：如果回應中包含兩個有序列表，每個列表中有四個元素，這樣下面兩個測試都會通過。
For example if the response contains two ordered lists, each with four nested list elements then the following tests will both pass.

```ruby
assert_select "ol" do |elements|
  elements.each do |element|
    assert_select element, "li", 4
  end
end

assert_select "ol" do
  assert_select "li", 8
end
```

這個斷言是相當好用的，更多進階用法可以看這一篇 [documentation](https://github.com/rails/rails-dom-testing/blob/master/lib/rails/dom/testing/assertions/selector_assertions.rb)。
This assertion is quite powerful. For more advanced usage, refer to its [documentation](https://github.com/rails/rails-dom-testing/blob/master/lib/rails/dom/testing/assertions/selector_assertions.rb).

### Additional View-Based Assertions
### 其他基本畫面(View)的斷言

這邊有幾個很常用在畫面(View)測試的斷言：
There are more assertions that are primarily used in testing views:

| Assertion                                                 | Purpose |
| --------------------------------------------------------- | ------- |
| `assert_select_email`                                     | Allows you to make assertions on the body of an e-mail. |
| `assert_select_encoded`                                   | Allows you to make assertions on encoded HTML. It does this by un-encoding the contents of each element and then calling the block with all the un-encoded elements.|
| `css_select(selector)` or `css_select(element, selector)` | Returns an array of all the elements selected by the _selector_. In the second variant it first matches the base _element_ and tries to match the _selector_ expression on any of its children. If there are no matches both variants return an empty array.|

下面是使用 `assert_select_email` 的範例：
Here's an example of using `assert_select_email`:

```ruby
assert_select_email do
  assert_select "small", "Please click the 'Unsubscribe' link if you want to opt-out."
end
```

測試小幫手 Testing Helpers
---------------

小幫手是一個簡單的模塊，裡面會有一些方法，這些方法你可以在畫面(view)中使用。
A helper is just a simple module where you can define methods which are
available in your views.

為了測試小幫手，你需要做的就是確認小幫手裡面的方法，有沒有跟你預期的一樣，與小助手相關的測試在 `test/helpers` 資料夾裡面。
In order to test helpers, all you need to do is check that the output of the
helper method matches what you'd expect. Tests related to the helpers are
located under the `test/helpers` directory.

假設我們定義一個小幫手：
Given we have the following helper:

```ruby
module UsersHelper
  def link_to_user(user)
    link_to "#{user.first_name} #{user.last_name}", user
  end
end
```

我們可以測試這個方法的輸出，像這樣：
We can test the output of this method like this:

```ruby
class UsersHelperTest < ActionView::TestCase
  test "should return the user's full name" do
    user = users(:david)

    assert_dom_equal %{<a href="/user/#{user.id}">David Heinemeier Hansson</a>}, link_to_user(user)
  end
end
```

此外，因為這個測試類別繼承自 `ActionView::TestCase` ，所以你可以使用Rails的小幫手方法，像是 `link_to` 、 `pluralize`。
Moreover, since the test class extends from `ActionView::TestCase`, you have
access to Rails' helper methods such as `link_to` or `pluralize`.

測試你的信件 Testing Your Mailers
--------------------

測試信件類別需要一些特別的工具來做這件事情
Testing mailer classes requires some specific tools to do a thorough job.

### Keeping the Postman in Check
### 檢查信件運作正常

你的信件類別：和其他Rails的應用程式一樣，應該要被測試以確保他們能如預期的工作。
Your mailer classes - like every other part of your Rails application - should be tested to ensure that they are working as expected.

測試信件類別的目標是確保：
The goals of testing your mailer classes are to ensure that:

* 信件是可以運作的 (新增、寄送)
* 信件內容是正確的 (主題、寄信人、內容...等等)
* 確保信件是在正確的時間點被寄出去

* emails are being processed (created and sent)
* the email content is correct (subject, sender, body, etc)
* the right emails are being sent at the right times

#### From All Sides
#### 全面測試

有兩個方向去測試信件，單元測試和功能測試，在單元測試，你使用嚴格的控制輸入來獨立執行寄送信件，並且和已知值(夾具feature)做比較。在功能測試，不用測的這麼仔細，只要確保 `controller` 、 `model` 有正確的運作使用信件流程，並在正確的時間點寄出信件。
There are two aspects of testing your mailer, the unit tests and the functional tests. In the unit tests, you run the mailer in isolation with tightly controlled inputs and compare the output to a known value (a fixture). In the functional tests you don't so much test the minute details produced by the mailer; instead, we test that our controllers and models are using the mailer in the right way. You test to prove that the right email was sent at the right time.

### Unit Testing
### 單元測試

為了測試你的信件有如預期般的運作，你可以使用單元測試用你預先寫好的值，跟使用上真的會得到的結果來做比較。
In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.

#### Revenge of the Fixtures
#### 夾具(feature)的另外功用

在單元測試中，夾具(feature)用於設定期望得到的值。因為這些夾具(feature)是範例信件，不是 `Active Record` 數據，所以要和其他夾具(feature)分開，放在單獨的子目錄中。這個子目錄位於 `test/fixtures` 資料夾中，其名稱與信件程序對應。例如，信件 `UserMailer` 使用的夾具(feature)存在 `test/fixtures/user_mailer` 資料夾中。
For the purposes of unit testing a mailer, fixtures are used to provide an example of how the output _should_ look. Because these are example emails, and not Active Record data like the other fixtures, they are kept in their own subdirectory apart from the other fixtures. The name of the directory within `test/fixtures` directly corresponds to the name of the mailer. So, for a mailer named `UserMailer`, the fixtures should reside in `test/fixtures/user_mailer` directory.

如果你生成你的信件，生成器不會為幫信件 `actions` 產生 `stub fixtures`，你必須如上所述創造這些文件。
If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above.

#### The Basic Test Case
#### 基本的測試用例子

下面是一個單元測試，用來測試叫做 `UserMailer` 的 `invite` 動作，這個動作是用來向朋友發送邀請，這段程式碼改進了生成器為 `invite` 動作生成的測試。
Here's a unit test to test a mailer named `UserMailer` whose action `invite` is used to send an invitation to a friend. It is an adapted version of the base test created by the generator for an `invite` action.

```ruby
require "test_helper"

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com",
                                     "friend@example.com", Time.now)

    # Send the email, then test that it got queued
    assert_emails 1 do
      email.deliver_now
    end

    # Test the body of the sent email contains what we expect it to
    assert_equal ["me@example.com"], email.from
    assert_equal ["friend@example.com"], email.to
    assert_equal "You have been invited by me@example.com", email.subject
    assert_equal read_fixture("invite").join, email.body.to_s
  end
end
```
在這個測試，我們新增一個信件、並把返回物件賦值給email變數，首先，我們確保信件已經發送了，再來確認信件包含預期的內容， `read_fixture` 這個小幫手的作用是從指定的文件中讀取內容。
In the test we create the email and store the returned object in the `email` variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect. The helper `read_fixture` is used to read in the content from this file.

標註： `email.body.to_s` 只會在HTML和文本兩者其中之一存在的時候存在，如果 `mailer` 兩個都有提供，你可以使用 `email.text_part.body.to_s` 或 `email.html_part.body.to_s`，來針對特定的部分測試夾具(fixture)。
NOTE: `email.body.to_s` is present when there's only one (HTML or text) part present. If the mailer provides both, you can test your fixture against specific parts with `email.text_part.body.to_s` or `email.html_part.body.to_s`.

這裡是 `invite` 夾具(fixture)的內容：
Here's the content of the `invite` fixture:

```
Hi friend@example.com,

You have been invited.

Cheers!
```

現在我們來更深入的了解你的信件測試，在 `config/environments/test.rb` 文件中，有這麼一行設置 `：ActionMailer::Base.delivery_method = :test`。這行設定把發送信件的方法設為 `:test` ，所以信件並不會真的發送出去（避免測試時騷擾用戶），而是添加到一個陣列中（`ActionMailer::Base.deliveries`）。
This is the right time to understand a little more about writing tests for your mailers. The line `ActionMailer::Base.delivery_method = :test` in `config/environments/test.rb` sets the delivery method to test mode so that email will not actually be delivered (useful to avoid spamming your users while testing) but instead it will be appended to an array (`ActionMailer::Base.deliveries`).

備註： `ActionMailer::Base.deliveries` 陣列只會在 `ActionMailer::TestCase` 和 `ActionDispatch::IntegrationTest` 測試中自動重新設定，如果你想要在測試之外有乾淨的陣列，你可以用手動重設定 `ActionMailer::Base.deliveries.clear`。

NOTE: The `ActionMailer::Base.deliveries` array is only reset automatically in `ActionMailer::TestCase` and `ActionDispatch::IntegrationTest` tests. If you want to have a clean slate outside these test cases, you can reset it manually with: `ActionMailer::Base.deliveries.clear`

#### Testing Enqueued Emails
#### 測試排隊的信件

你可以使用 `assert_enqueued_email_with` 斷言去確認，信件已經和所有預期的信件方法參數、參數化的信件參數一起排隊，這可以讓你去匹配任何已經使用 `deliver_later` 方法的信件。
You can use the `assert_enqueued_email_with` assertion to confirm that the email has been enqueued with all of the expected mailer method arguments and/or parameterized mailer parameters. This allows you to match any email that have been enqueued with the `deliver_later` method.

和基本的測試用例一樣，我們新增一個信件，並把返回物件賦值給 `email` 變數，以下範例包含傳遞參數、引數的變動。
As with the basic test case, we create the email and store the returned object in the `email` variable. The following examples include variations of passing arguments and/or parameters.

這個範例將會斷言，信件會使用正確的引數做排隊：
This example will assert that the email has been enqueued with the correct arguments:

```ruby
require "test_helper"

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end
```

這個範例會斷言，透過將參數的 `hash` 作為 `args` 傳遞，信件已使用叫做 `arguments` 的正確信件方法排隊：
This example will assert that a mailer has been enqueued with the correct mailer method named arguments by passing a hash of the arguments as `args`:

```ruby
require "test_helper"

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.create_invite(from: "me@example.com", to: "friend@example.com")

    # Test that the email got enqueued with the correct named arguments
    assert_enqueued_email_with UserMailer, :create_invite, args: [{ from: "me@example.com",
                                                                    to: "friend@example.com" }] do
      email.deliver_later
    end
  end
end
```

此範例將會斷言，參數化的信件已使用正確的參數和引數進行排隊，信件參數用 `params` 做傳遞，並且信件方法的引數是 `args`：
This example will assert that a parameterized mailer has been enqueued with the correct parameters and arguments. The mailer parameters are passed as `params` and the mailer method arguments as `args`:

```ruby
require "test_helper"

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(all: "good").create_invite("me@example.com", "friend@example.com")

    # Test that the email got enqueued with the correct mailer parameters and arguments
    assert_enqueued_email_with UserMailer, :create_invite, params: { all: "good" },
                                                           args: ["me@example.com", "friend@example.com"] do
      email.deliver_later
    end
  end
end
```

這個範例展示了另外一個測試參數化信件，是否有使用正確的參數做排隊的方法：
This example shows an alternative way to test that a parameterized mailer has been enqueued with the correct parameters:

```ruby
require "test_helper"

class UserMailerTest < ActionMailer::TestCase
  test "invite" do
    # Create the email and store it for further assertions
    email = UserMailer.with(to: "friend@example.com").create_invite

    # Test that the email got enqueued with the correct mailer parameters
    assert_enqueued_email_with UserMailer.with(to: "friend@example.com"), :create_invite do
      email.deliver_later
    end
  end
end
```

### Functional and System Testing
### 功能和系統測試

單元測試允我們去測試信件的屬性，而功能測試、系統測試允許我們測試用戶交互互動是否適當的觸發信件的發送，例如，你可以檢查，邀請朋友的操作是否有成功寄出信件：
Unit testing allows us to test the attributes of the email while functional and system testing allows us to test whether user interactions appropriately trigger the email to be delivered. For example, you can check that the invite friend operation is sending an email appropriately:

```ruby
# Integration Test
require "test_helper"

class UsersControllerTest < ActionDispatch::IntegrationTest
  test "invite friend" do
    # Asserts the difference in the ActionMailer::Base.deliveries
    assert_emails 1 do
      post invite_friend_url, params: { email: "friend@example.com" }
    end
  end
end
```

```ruby
# System Test
require "test_helper"

class UsersTest < ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_chrome

  test "inviting a friend" do
    visit invite_users_url
    fill_in "Email", with: "friend@example.com"
    assert_emails 1 do
      click_on "Invite"
    end
  end
end
```

備註： `assert_emails` 方法不依賴特定的傳遞方法，並且適用於使用 `deliver_now` 、 `deliver_later` 方法傳遞的信件。如果我們明確的想要斷言信件已經排好隊，可以使用 `assert_enqueued_email_with` ([examples above](#testing-enqueued-emails)) 或者 `assert_enqueued_emails` 方法， 更多資訊可以在這邊找到 [documentation here](https://api.rubyonrails.org/classes/ActionMailer/TestHelper.html)。

NOTE: The `assert_emails` method is not tied to a particular deliver method and will work with emails delivered with either the `deliver_now` or `deliver_later` method. If we explicitly want to assert that the email has been enqueued we can use the `assert_enqueued_email_with` ([examples above](#testing-enqueued-emails)) or `assert_enqueued_emails` methods. More information can be found in the [documentation here](https://api.rubyonrails.org/classes/ActionMailer/TestHelper.html).

工作測試 Testing Jobs
------------

由於你可以在你的應用程式裡面，客製的工作可以在不同層級被排列，你將會需要測試這些工作(測試他們排隊時的行為)，還有測試有沒有正確去排隊。
Since your custom jobs can be queued at different levels inside your application,
you'll need to test both the jobs themselves (their behavior when they get enqueued)
and that other entities correctly enqueue them.

### A Basic Test Case
### 基本的測試用例

預設情況下，當你生成一個工作，一個相對應的測試會自動生成在 `test/jobs` 資料夾，下面是付款工作的測試範例：
By default, when you generate a job, an associated test will be generated as well
under the `test/jobs` directory. Here's an example test with a billing job:

```ruby
require "test_helper"

class BillingJobTest < ActiveJob::TestCase
  test "that account is charged" do
    BillingJob.perform_now(account, product)
    assert account.reload.charged_for?(product)
  end
end
```

這個測試非常簡單，並且只要斷言這個工作會如預期般的結束
This test is pretty simple and only asserts that the job got the work done
as expected.

預設下， `ActiveJob::TestCase` 將會把排隊調整器設定為 `:test`，因此你的工作會排隊進行，他還會確保在任何測試執行之前，先清除之前執行和排隊的工作，因此我們可以放心的假設當前測試範圍內沒有執行任何工作。

By default, `ActiveJob::TestCase` will set the queue adapter to `:test` so that
your jobs are performed inline. It will also ensure that all previously performed
and enqueued jobs are cleared before any test run so you can safely assume that
no jobs have already been executed in the scope of each test.

### Custom Assertions and Testing Jobs inside Other Components
### 在其他組建內客製斷言和測試作業

`Active Job` 自帶了很多自定義的斷言，可以簡化測試。可用的斷言列表參見[`ActiveJob::TestHelper`](https://api.rubyonrails.org/classes/ActiveJob/TestHelper.html)。
Active Job ships with a bunch of custom assertions that can be used to lessen the verbosity of tests. For a full list of available assertions, see the API documentation for [`ActiveJob::TestHelper`](https://api.rubyonrails.org/classes/ActiveJob/TestHelper.html).


不管工作是在哪裡調用的（例如在controller中），最好都要測試工作能正確入隊或執行。這時就體現了 `Active Job` 提供的自定義斷言的用處。例如，在model中：

It's a good practice to ensure that your jobs correctly get enqueued or performed
wherever you invoke them (e.g. inside your controllers). This is precisely where
the custom assertions provided by Active Job are pretty useful. For instance,
within a model:

```ruby
require "test_helper"

class ProductTest < ActiveSupport::TestCase
  include ActiveJob::TestHelper

  test "billing job scheduling" do
    assert_enqueued_with(job: BillingJob) do
      product.charge(account)
    end
  end
end
```

Testing Action Cable
--------------------

因為在你的應用程式裡， `Action Cable` 被使用於不同的層級，所以你需要同時測試通道(channels)、連結類別(connection classes)，而且要確認其他實體(entities)是否廣播(broadcast)正確的消息。
Since Action Cable is used at different levels inside your application,
you'll need to test both the channels, connection classes themselves, and that other
entities broadcast correct messages.

### Connection Test Case
### 連結測試用例

預設下，當你使用 `Action Cable` 產生新的Rails應用程式，會在`test/channels/application_cable` 資料夾裡面，生成基本的連接類別(`ApplicationCable::Connection`)的測試。
By default, when you generate new Rails application with Action Cable, a test for the base connection class (`ApplicationCable::Connection`) is generated as well under `test/channels/application_cable` directory.

連結測試的目標是確認連接的標示符是否正確的分配，或者是拒絕任何不適當的連結請求。下面是一個例子：
Connection tests aim to check whether a connection's identifiers get assigned properly
or that any improper connection requests are rejected. Here is an example:

```ruby
class ApplicationCable::ConnectionTest < ActionCable::Connection::TestCase
  test "connects with params" do
    # Simulate a connection opening by calling the `connect` method
    connect params: { user_id: 42 }

    # You can access the Connection object via `connection` in tests
    assert_equal connection.user_id, "42"
  end

  test "rejects connection without params" do
    # Use `assert_reject_connection` matcher to verify that
    # connection is rejected
    assert_reject_connection { connect }
  end
end
```
你還可以像在整合測試那樣，指定請求cookie：
You can also specify request cookies the same way you do in integration tests:

```ruby
test "connects with cookies" do
  cookies.signed[:user_id] = "42"

  connect

  assert_equal connection.user_id, "42"
end
```
看這個API文件得到更多資訊 [`ActionCable::Connection::TestCase`](https://api.rubyonrails.org/classes/ActionCable/Connection/TestCase.html)。
See the API documentation for [`ActionCable::Connection::TestCase`](https://api.rubyonrails.org/classes/ActionCable/Connection/TestCase.html) for more information.

### Channel Test Case
### 通道測試用例

預設下，當你產生一個通道(channel)，還會在 `test/channels` 資料夾裡面，生成一個相關的測試，這邊有一個聊天頻道的測試範例：
By default, when you generate a channel, an associated test will be generated as well
under the `test/channels` directory. Here's an example test with a chat channel:

```ruby
require "test_helper"

class ChatChannelTest < ActionCable::Channel::TestCase
  test "subscribes and stream for room" do
    # Simulate a subscription creation by calling `subscribe`
    subscribe room: "15"

    # You can access the Channel object via `subscription` in tests
    assert subscription.confirmed?
    assert_has_stream "chat_15"
  end
end
```
這個測試非常簡單，他只有斷言此頻道訂閱特定串流的連結。
This test is pretty simple and only asserts that the channel subscribes the connection to a particular stream.

你還可以指定底層連結標示符，這裡有一個網站通知頻道的測試範例：
You can also specify the underlying connection identifiers. Here's an example test with a web notifications channel:

```ruby
require "test_helper"

class WebNotificationsChannelTest < ActionCable::Channel::TestCase
  test "subscribes and stream for user" do
    stub_connection current_user: users(:john)

    subscribe

    assert_has_stream_for users(:john)
  end
end
```

看這個API文件得到更多的資訊 [`ActionCable::Channel::TestCase`](https://api.rubyonrails.org/classes/ActionCable/Channel/TestCase.html)。
See the API documentation for [`ActionCable::Channel::TestCase`](https://api.rubyonrails.org/classes/ActionCable/Channel/TestCase.html) for more information.

### Custom Assertions And Testing Broadcasts Inside Other Components
### 其他組建內部的客製化斷言和測試廣播

`Action Cable` 自帶了一堆字定義的斷言，可用於減少測試的冗長情況，這邊有完整可用的斷言列表，看這個API文件 [`ActionCable::TestHelper`](https://api.rubyonrails.org/classes/ActionCable/TestHelper.html)。
Action Cable ships with a bunch of custom assertions that can be used to lessen the verbosity of tests. For a full list of available assertions, see the API documentation for [`ActionCable::TestHelper`](https://api.rubyonrails.org/classes/ActionCable/TestHelper.html).

確保在其他組建內(e.g. 你的 `controllers` 裡面)有廣播正確的訊息，是一個好作法，這就是 `Action Cable` 自定義斷言非常好用的地方，例如在model中：
It's a good practice to ensure that the correct message has been broadcasted inside other components (e.g. inside your controllers). This is precisely where
the custom assertions provided by Action Cable are pretty useful. For instance,
within a model:

```ruby
require "test_helper"

class ProductTest < ActionCable::TestCase
  test "broadcast status after charge" do
    assert_broadcast_on("products:#{product.id}", type: "charged") do
      product.charge(account)
    end
  end
end
```
如果你想要測試用 `Channel.broadcast_to` 製作的廣播，你應該使用 `Channel.broadcasting_for` 來產生底層串流名稱：
If you want to test the broadcasting made with `Channel.broadcast_to`, you should use
`Channel.broadcasting_for` to generate an underlying stream name:

```ruby
# app/jobs/chat_relay_job.rb
class ChatRelayJob < ApplicationJob
  def perform(room, message)
    ChatChannel.broadcast_to room, text: message
  end
end
```

```ruby
# test/jobs/chat_relay_job_test.rb
require "test_helper"

class ChatRelayJobTest < ActiveJob::TestCase
  include ActionCable::TestHelper

  test "broadcast message to room" do
    room = rooms(:all)

    assert_broadcast_on(ChatChannel.broadcasting_for(room), text: "Hi!") do
      ChatRelayJob.perform_now(room, "Hi!")
    end
  end
end
```

測試預先加載 Testing Eager Loading
---------------------

通常，應用程式不在急於在 `開發 development` 、 `測試 test` 環境中加載，以加快速度，但我們會在 `生產 production` 環境的時候來做加載。
Normally, applications do not eager load in the `development` or `test` environments to speed things up. But they do in the `production` environment.

如果專案中某些文件因為某些原因不能被加載，你最好在部署到 `生產 production` 環境前檢測到他，對嗎？
If some file in the project cannot be loaded for whatever reason, you better detect it before deploying to production, right?

### Continuous Integration
### 設定整合

如果你的專案有 `持續整合 CI`，在 `持續整合 CI` 中的預先加載，就是一個簡單的方式去確保應用程式有預先加載。
If your project has CI in place, eager loading in CI is an easy way to ensure the application eager loads.

`持續整合 CI` 通常會設定一些環境變數，用來指示測試套件應該在哪裡運行，例如下面這樣，環境變數設定為 `CI`：
CIs typically set some environment variable to indicate the test suite is running there. For example, it could be `CI`:

```ruby
# config/environments/test.rb
config.eager_load = ENV["CI"].present?
```

從Rails 7開始，新生成的應用程式以這種方式設定。
Starting with Rails 7, newly generated applications are configured that way by default.

### Bare Test Suites

如果你的專案沒有 `持續整合 CI`，你仍然可以在測試插件中，呼叫 `Rails.application.eager_load!` 來達成預先加載。
If your project does not have continuous integration, you can still eager load in the test suite by calling `Rails.application.eager_load!`:

#### Minitest

```ruby
require "test_helper"

class ZeitwerkComplianceTest < ActiveSupport::TestCase
  test "eager loads all files without errors" do
    assert_nothing_raised { Rails.application.eager_load! }
  end
end
```

#### RSpec

```ruby
require "rails_helper"

RSpec.describe "Zeitwerk compliance" do
  it "eager loads all files without errors" do
    expect { Rails.application.eager_load! }.not_to raise_error
  end
end
```

其他測試資源 Additional Testing Resources
----------------------------

### Testing Time-Dependent Code
### 測試與時間有關的程式碼

Rails內建有提供一些小幫手方法，可以讓你斷言你設定的時間有如預期。
Rails provides built-in helper methods that enable you to assert that your time-sensitive code works as expected.

這裡有一個範例是使用 [`travel_to`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to) 小幫手：
Here is an example using the [`travel_to`](https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to) helper:

```ruby
# Lets say that a user is eligible for gifting a month after they register.
user = User.create(name: "Gaurish", activation_date: Date.new(2004, 10, 24))
assert_not user.applicable_for_gifting?
travel_to Date.new(2004, 11, 24) do
  assert_equal Date.new(2004, 10, 24), user.activation_date # inside the `travel_to` block `Date.current` is mocked
  assert user.applicable_for_gifting?
end
assert_equal Date.new(2004, 10, 24), user.activation_date # The change was visible only inside the `travel_to` block.
```

可以看這個時間小幫手的API文件，來得到更多的資訊 [`ActiveSupport::Testing::TimeHelpers` API Documentation](https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html)。
Please see [`ActiveSupport::Testing::TimeHelpers` API Documentation](https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html)
for in-depth information about the available time helpers.
 