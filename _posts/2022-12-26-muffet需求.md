---
title: 學習日誌
author: YeeChen
date: 2022-12-26
category: WEB
layout: post
---


> ---    
> **前情提要：**         
> 這裡整理所有 muffet 需求
>    
> ---    
{: .block-tip}






2878 - 把 sku 的格式改成跟客戶的 content_ids 一樣
------

### 詳細描述
目錄的內容編號或是商品群組編號，可以調整成跟像素「426783434563478」抓的「content_ids」一樣嗎？
例如：https://www.jdgift.com.tw/products/strnetwork 這個商品就是「643e7b3ab788e30017cc3fd9:643e7b3ac27c1b4855c3e631」
 

### 解決方法


打開任意產品網頁，並用 Meta Pixel Helper 看 (客戶的 pixel 是 426783434563478)，產品的 contents_id 是 `["641428823f2332000e3cd7e2:641428825a4a140012c5ad5c"]`
後面那一段，`641428825a4a140012c5ad5c`，就是子類商品的ID，因為子類商品ID，就需要用到 variants 這個參數，這個參數加上去，會讓觸發 `api` 這個 repo 裡面的設定。

詳細資料看這個連結：https://github.com/Tagtoo/api/blob/master/apps/feed/tools.py



主要就是下面三段：

Ps. 最後產出的 feed 長這樣：`http://api.tagtoo.com.tw/v3/feed/facebook/2878`

#### 產 feed
```py
# api / apps / feed / views/py

class FacebookV3(Facebook):
    """
    XML feed with variants extension for Facebok Dynamic Product Ads.
    """
    template = 'feed/facebook_feed.xml'

    def get(self, advertiser_id):
        logging.info(advertiser_id)
        advertiser, products = self.get_advertiser_and_products(advertiser_id)
        if not advertiser or advertiser_id == '1186':
            return self.return_404()
        else:
            products = extend_product_variants(products)

        self.format_to_xml(products)
        return self.items_to_xml(products, advertiser)
```

#### 判斷是否有帶 variants 參數

如果今天沒帶該參數，就是這一段 `new_products.append(product)`，如果有帶參數，就是下面一整大段，主要用到就是這個函數 `set_variant_product_key_for_different_ec`

```py
# api / apps / feed / tools.py

def extend_product_variants(products):
    new_products = []
    for product in products:
        variants = product['extra'].get('variants')
        if not variants:
            new_products.append(product)
        else:
            for variant in variants:
                new_product = copy.copy(product)
                new_product['product_key'] = set_variant_product_key_for_different_ec(product, variant)
                new_product['title'] = variant.get(
                    'title',
                    product['title']
                )
                new_product['description'] = set_variant_description_for_different_ec(product, variant)
                new_product['color'] = set_variant_color_for_different_ec(product, variant)
                new_product['size'] = variant.get('size')
                new_product['image_url'] = variant.get(
                    'image',
                    product['image_url']
                )
                new_product['price'] = variant.get(
                    'sale_price',
                    product['price']
                )
                new_product['store_price'] = variant.get(
                    'price',
                    product['store_price']
                )
                new_product['live'] = variant.get('in_stock', product['live'])
                if variant.get('link'):
                    new_product['link'] = variant['link']
                    new_product['ad_click_link'] = re.sub(
                        ur'([&\?])u=[^&]+',
                        lambda m: u'{}u={}'.format(
                            m.group(1),
                            urllib.quote_plus(new_product['link'])
                        ),
                        new_product['ad_click_link']
                    )
                new_products.append(new_product)

    # Make new_products unique with product_key
    new_products = tuple(
        {product["product_key"]: product for product in new_products}.values()
    )
    return new_products
```


#### 客製產品的 content_id

我這次客戶是 2878，所以可以看到最後產出 content_id 的是這樣 `return ':'.join([product['product_key'].split(':')[-1], variant['id']])`

ps. 傳進塔圖資料庫的產品格式是正常有prefix的格式，只是產出的feed會是客製的格式
```py
# api / apps / feed / tools.py

def set_variant_product_key_for_different_ec(product, variant):
    if product['advertiser_id'] == 1843:
        split_parts = product['product_key'].split(':')
        split_parts[-1] = variant['id']
        return ':'.join(split_parts)
    if product['advertiser_id'] == 1626:  # wstyle
        return '{}_{}'.format(product['product_key'], variant['color'])
    if product['advertiser_id'] == 1165:  # Edwin
        return 'edwin:product:{}'.format(variant['id'])
    if product['advertiser_id'] == 1507:  # deerdogs
        return 'deerdogs:product:{}'.format(variant['id'])
    if product['advertiser_id'] == 2050:  # maisonoishi
        return variant['id']
    if product['advertiser_id'] in (2808, 1474, 2039, 2878):  # To match client's pixel rule
        return ':'.join([product['product_key'].split(':')[-1], variant['id']])

    return u'{}-{}'.format(
        product['product_key'],
        variant['id']
    )d
```


2878 - line 目錄的到達網址統一改成指定格式
------

### 詳細描述
Line 目錄每個商品的到達網址後面可以幫我統一加上「utm_source=tagtoo&utm_medium=cpc&utm_term=2878:474:0」這個嗎～感恩


### 解決方法

https://github.com/Tagtoo/cron-jobs/pull/187

到 Tagtoo / cron-jobs 這個 repo，加上下面這一段

```md
> cron_jobs / line_lap_feed / config.yaml

> 2878:
>   source: tagtoo
>   medium: cpc
>   term: 2878:474:0
```

cron_jobs 的目的 -> 






facebook 要設定 s2s 
------

今天要設定 s2s 的話，OP 會幫忙把像素設定好，我們這邊就要把 `unitrack` 補上


### 原始樣式

這個是新客一定要設定的
```json
  "unitrack": {
    "token": "584391d9e16be5aae9f6faf49944d39d42bd4800081a1a9415324cd627e4",
    "scopes": ["tagtoo"]
  }
```

### s2s 樣式

多加上 facebook，這樣設定好後，howard 會到後端，也就是產出這個 token 的地方，開 s2s 的權限
```json
  "unitrack": {
    "token": "584391d9e16be5aae9f6faf49944d39d42bd4800081a1a9415324cd627e4",
    "scopes": ["facebook", "tagtoo"]
  }
```


### 設定 unitrack

基本上 unitrack 在一開始就會抓信箱、電話的資訊了，這邊只是再提醒一次
```js
tracker('unitrack', 'add', { phone, email })
tracker('unitrack', 'add', { email })
```






2930 要做 tagtoo event
------


### 需求表

```md
> Timestamp	填表人	   負責 OP	      EC ID	  問題/需求 類別	 渠道	      EC 網站網址(無則隨意填)	      
> 6/9/2023  16:00:47	jasmine ting 	2930	  新客戶	        Facebook	 https://munich-stars.com/	
> 
> 
> 問題詳述	                                    附加檔案	    優先度	承接人	開始處理時間	完成時間	校正類別	處理辦法	編號
> 要做tagtoo event，廣告帳號：273380295128678		               一般	  John					                               3614
```


### 解決方法

(1) 先跟 patrick 要 facebook 權限

(2) 把 tagtoo 的事件加進 muffet 檔案裡面，tagtoo 事件介紹 - https://github.com/Tagtoo/muffet/issues/1714

(3) tagtoo 事件，主要就是 unitrack 事件，所以把 unitrack 加進去就好

(4) 不過目前這個客戶已經把 unitrack 設定好，所以我只要把 facebook 追蹤補上就好


(5) 原本的 conf.json 設定
```json
{
  "id": 2930,
  "google": { "trackIds": [["UA-34980571-47"], ["G-Q6JM6HV2LC"], ["G-K0W8FRESYH"]] },
  "unitrack": {
    "token": "584391d9e16be5aae9f6faf49944d39d42bd4800081a1a9415324cd627e4",
    "scopes": ["tagtoo"]
  }
}
```

(6) 改進的 conf.json 設定
```json

```


(7) 如果今天客戶沒有設定facebook pixel，就要幫她設定


到 `https://business.facebook.com/home/accounts?global_scope_id=822361161148101&business_id=822361161148101` 這個連結，找到指定的客戶，並點擊 `事件管理工具`，進到這個頁面後，就可以看到相關的這個客戶目前建置的所有像素，











GMC 用 dashboard-api
tagtoo NEW -> GKE -> workloads



ec repo -> 後端爬蟲

rss 欄位，存放客戶 endpoion 的資訊



tagtoo 產 feed 服務

這兩個 repo 變動很快速

先在 local 跑一次，就直接上，不用跑 staging

local 直接連到 db 資料

起一台 server  - 直接連到 db - 產 feed (跑 docker)


如何起服務，從 cicd流程，


更改 db 的 setting





上面是 dashboard api 服務


api 服務

什麼情況下，feed 會有 v1v2v3



先跟op 確認網址形式

因為 3 種形式都不一樣

v1 - 摋
v2 -
v3 - 子產品
api/apps/feed/views.py







GAE -> tagtoo new -> api -> 









